root=false

#######################################################
## C# specific rules (.cs files)
#######################################################
[*.cs]
#######################################################
## Specific rules
#######################################################

#######################################################
## Microsoft.CodeAnalysis.NetAnalyzers
#######################################################
## CA1040 : Avoid empty interfaces (category : Design / default: warning)
## Interfaces define members that provide a behavior or usage contract. The functionality that is described by the interface can be adopted by any type, regardless of where the type appears in the inheritance hierarchy. A type implements an interface by providing implementations for the members of the interface. An empty interface does not define any members; therefore, it does not define a contract that can be implemented.
dotnet_diagnostic.CA1040.severity = none ## Redundante with S4023
## CA2007 : Consider calling ConfigureAwait on the awaited task (category : Reliability / default: warning)
## When an asynchronous method awaits a Task directly, continuation occurs in the same thread that created the task. Consider calling Task.ConfigureAwait(Boolean) to signal your intention for continuation. Call ConfigureAwait(false) on the task to schedule continuations to the thread pool, thereby avoiding a deadlock on the UI thread. Passing false is a good option for app-independent libraries. Calling ConfigureAwait(true) on the task has the same behavior as not explicitly calling ConfigureAwait. By explicitly calling this method, you're letting readers know you intentionally want to perform the continuation on the original synchronization context.
dotnet_diagnostic.CA2007.severity = none ## ASP.NET Core don't have Synchronization context so using ConfigureAwait don't make sense.
## CA1707 : Identifiers should not contain underscores (category : Naming / default: none)
## By convention, identifier names do not contain the underscore (_) character. This rule checks namespaces, types, members, and parameters.
dotnet_diagnostic.CA1707.severity = none ## Useless, define more fine grained rules in naming conventions.
## CA1707 : Identifiers should not contain underscores (category : Naming / default: none)
## By convention, identifier names do not contain the underscore (_) character. This rule checks namespaces, types, members, and parameters.
dotnet_diagnostic.CA1707.severity = none ## Useless, define more fine grained rules in naming conventions.
## CA1707 : Identifiers should not contain underscores (category : Naming / default: none)
## By convention, identifier names do not contain the underscore (_) character. This rule checks namespaces, types, members, and parameters.
dotnet_diagnostic.CA1707.severity = none ## Useless, define more fine grained rules in naming conventions.
## CA1707 : Identifiers should not contain underscores (category : Naming / default: none)
## By convention, identifier names do not contain the underscore (_) character. This rule checks namespaces, types, members, and parameters.
dotnet_diagnostic.CA1707.severity = none ## Useless, define more fine grained rules in naming conventions.
## CA1707 : Identifiers should not contain underscores (category : Naming / default: none)
## By convention, identifier names do not contain the underscore (_) character. This rule checks namespaces, types, members, and parameters.
dotnet_diagnostic.CA1707.severity = none ## Useless, define more fine grained rules in naming conventions.
## CA1707 : Identifiers should not contain underscores (category : Naming / default: none)
## By convention, identifier names do not contain the underscore (_) character. This rule checks namespaces, types, members, and parameters.
dotnet_diagnostic.CA1707.severity = none ## Useless, define more fine grained rules in naming conventions.
## CA1707 : Identifiers should not contain underscores (category : Naming / default: none)
## By convention, identifier names do not contain the underscore (_) character. This rule checks namespaces, types, members, and parameters.
dotnet_diagnostic.CA1707.severity = none ## Useless, define more fine grained rules in naming conventions.
## CA1707 : Identifiers should not contain underscores (category : Naming / default: none)
## By convention, identifier names do not contain the underscore (_) character. This rule checks namespaces, types, members, and parameters.
dotnet_diagnostic.CA1707.severity = none ## Useless, define more fine grained rules in naming conventions.
## CA1014 : Mark assemblies with CLSCompliant (category : Design / default: warning)
## The Common Language Specification (CLS) defines naming restrictions, data types, and rules to which assemblies must conform if they will be used across programming languages. Good design dictates that all assemblies explicitly indicate CLS compliance by using CLSCompliantAttribute . If this attribute is not present on an assembly, the assembly is not compliant.
dotnet_diagnostic.CA1014.severity = none
## CA1034 : Nested types should not be visible (category : Design / default: warning)
## A nested type is a type that is declared in the scope of another type. Nested types are useful to encapsulate private implementation details of the containing type. Used for this purpose, nested types should not be externally visible.
dotnet_diagnostic.CA1034.severity = suggestion ## Visible neested type can be usefull (Constant organization for exemple).
## CA1034 : Nested types should not be visible (category : Design / default: warning)
## A nested type is a type that is declared in the scope of another type. Nested types are useful to encapsulate private implementation details of the containing type. Used for this purpose, nested types should not be externally visible.
dotnet_diagnostic.CA1034.severity = suggestion ## Visible neested type can be usefull (Constant organization for exemple).
## CA1056 : URI-like properties should not be strings (category : Design / default: warning)
## This rule assumes that the property represents a Uniform Resource Identifier (URI). A string representation of a URI is prone to parsing and encoding errors, and can lead to security vulnerabilities. The System.Uri class provides these services in a safe and secure manner.
dotnet_diagnostic.CA1056.severity = none ## Redundante with S4005
## CA1024 : Use properties where appropriate (category : Design / default: warning)
## A public or protected method has a name that starts with ""Get"", takes no parameters, and returns a value that is not an array. The method might be a good candidate to become a property.
dotnet_diagnostic.CA1024.severity = none ## Redundante with S4049
## CA1062 : Validate arguments of public methods (category : Design / default: warning)
## An externally visible method dereferences one of its reference arguments without verifying whether that argument is 'null' ('Nothing' in Visual Basic). All reference arguments that are passed to externally visible methods should be checked against 'null'. If appropriate, throw an 'ArgumentNullException' when the argument is 'null'. If the method is designed to be called only by known assemblies, you should make the method internal.
dotnet_diagnostic.CA1062.severity = warning ## Lot of false positive with not nullable object.
## CA1308 : Normalize strings to uppercase (category : Globalization / default: warning)
## Strings should be normalized to uppercase. A small group of characters cannot make a round trip when they are converted to lowercase. To make a round trip means to convert the characters from one locale to another locale that represents character data differently, and then to accurately retrieve the original characters from the converted characters.
dotnet_diagnostic.CA1308.severity = none ## Not relevant.

#######################################################
## Microsoft.CodeAnalysis.CSharp.NetAnalyzers
#######################################################
## CA1812 : Avoid uninstantiated internal classes (category : Performance / default: warning)
## An instance of an assembly-level type is not created by code in the assembly.
dotnet_diagnostic.CA1812.severity = none ## Lot of false positive due to REPR

#######################################################
## SonarAnalyzer.CSharp
#######################################################
## S1451 : Track lack of copyright and license headers (category : Blocker Code Smell / default: warning)
## Each source file should start with a header stating file ownership and the license which must be used to distribute the application.
dotnet_diagnostic.S1451.severity = none ## We don't have licence header (especially usefull for OSS project.
## S1135 : Track uses of "TODO" tags (category : Info Code Smell / default: warning)
## Developers often use TODO tags to mark areas in the code where additional work or improvements are needed but are not implemented immediately. However, these TODO tags sometimes get overlooked or forgotten, leading to incomplete or unfinished code. This rule aims to identify and address unattended TODO tags to ensure a clean and maintainable codebase. This description explores why this is a problem and how it can be fixed to improve the overall code quality.
dotnet_diagnostic.S1135.severity = suggestion ## TODO comment are allowed.
## S126 : "if ... else if" constructs should end with "else" clauses (category : Critical Code Smell / default: warning)
## This rule applies whenever an if statement is followed by one or more else if statements; the final else if should be followed by an else statement.
dotnet_diagnostic.S126.severity = suggestion
## S4023 : Interfaces should not be empty (category : Minor Code Smell / default: warning)
## Empty interfaces should be avoided as they do not provide any functional requirements for implementing classes.
dotnet_diagnostic.S4023.severity = suggestion ## Should propose refactoring but not raise error.
## S1309 : Track uses of in-source issue suppressions (category : Info Code Smell / default: warning)
## This rule allows you to track the usage of the SuppressMessage attributes and #pragma warning disable mechanism.
dotnet_diagnostic.S1309.severity = none ## Suppression with justification is not problem, we just need to take care in review.
## S4055 : Literals should not be passed as localized parameters (category : Major Code Smell / default: warning)
## String literals embedded in the source code will not be localized properly.
dotnet_diagnostic.S4055.severity = none
## S1312 : Logger fields should be "private static readonly" (category : Minor Code Smell / default: warning)
## Regardless of the logging framework in use (Microsoft.Extension.Logging, Serilog, Log4net, NLog, …​​), logger fields should be:
dotnet_diagnostic.S1312.severity = none ## Static field can't be injected
## S3242 : Method parameters should be declared with base types (category : Minor Code Smell / default: warning)
## When a derived type is used as a parameter instead of the base type, it limits the uses of the method. If the additional functionality that is provided in the derived type is not required then that limitation isn’t required, and should be removed.
dotnet_diagnostic.S3242.severity = suggestion
## S2360 : Optional parameters should not be used (category : Critical Code Smell / default: warning)
## The overloading mechanism should be used in place of optional parameters for several reasons:
dotnet_diagnostic.S2360.severity = none
## S3059 : Types should not have members with visibility set higher than the type's visibility (category : Major Code Smell / default: warning)
## There’s no point in having a public member in a non-public type because objects that can’t access the type will never have the chance to access the member.
dotnet_diagnostic.S3059.severity = suggestion ## Lot of useless modifications when change append after initial code.
## S1144 : Unused private types or members should be removed (category : Major Code Smell / default: warning)
## This rule raises an issue when a private/internal type or member is never referenced in the code.
dotnet_diagnostic.S1144.severity = none ## Lot of false positive due to REPR
## S4005 : "System.Uri" arguments should be used instead of strings (category : Major Code Smell / default: warning)
## String representations of URIs or URLs are prone to parsing and encoding errors which can lead to vulnerabilities. The System.Uri class is a safe alternative and should be preferred.
dotnet_diagnostic.S4005.severity = suggestion


#######################################################
## Depricated rules
#######################################################


#######################################################
## Other rules : Define as error
#######################################################

#######################################################
## Microsoft.CodeAnalysis.NetAnalyzers
#######################################################
## CA1012 : Abstract types should not have public constructors (category : Design / default: warning)
## Constructors on abstract types can be called only by derived types. Because public constructors create instances of a type, and you cannot create instances of an abstract type, an abstract type that has a public constructor is incorrectly designed.
dotnet_diagnostic.CA1012.severity = error
## CA1005 : Avoid excessive parameters on generic types (category : Design / default: warning)
## The more type parameters a generic type contains, the more difficult it is to know and remember what each type parameter represents.
dotnet_diagnostic.CA1005.severity = error
## CA1021 : Avoid out parameters (category : Design / default: warning)
## Passing types by reference (using 'out' or 'ref') requires experience with pointers, understanding how value types and reference types differ, and handling methods with multiple return values. Also, the difference between 'out' and 'ref' parameters is not widely understood.
dotnet_diagnostic.CA1021.severity = error
## CA1068 : CancellationToken parameters must come last (category : Design / default: suggestion)
dotnet_diagnostic.CA1068.severity = error
## CA2227 : Collection properties should be read only (category : Usage / default: warning)
## A writable collection property allows a user to replace the collection with a different collection. A read-only property stops the collection from being replaced but still allows the individual members to be set.
dotnet_diagnostic.CA2227.severity = error
## CA1010 : Generic interface should also be implemented (category : Design / default: none)
## To broaden the usability of a type, implement one of the generic interfaces. This is especially true for collections as they can then be used to populate generic collection types.
dotnet_diagnostic.CA1010.severity = error
## CA1050 : Declare types in namespaces (category : Design / default: suggestion)
## Types are declared in namespaces to prevent name collisions and as a way to organize related types in an object hierarchy.
dotnet_diagnostic.CA1050.severity = error
## CA1019 : Define accessors for attribute arguments (category : Design / default: warning)
dotnet_diagnostic.CA1019.severity = error
## CA1019 : Define accessors for attribute arguments (category : Design / default: warning)
dotnet_diagnostic.CA1019.severity = error
## CA1019 : Define accessors for attribute arguments (category : Design / default: warning)
dotnet_diagnostic.CA1019.severity = error
## CA1031 : Do not catch general exception types (category : Design / default: warning)
## A general exception such as System.Exception or System.SystemException or a disallowed exception type is caught in a catch statement, or a general catch clause is used. General and disallowed exceptions should not be caught.
dotnet_diagnostic.CA1031.severity = none # Redundante with S2221
## CA1000 : Do not declare static members on generic types (category : Design / default: none)
## When a static member of a generic type is called, the type argument must be specified for the type. When a generic instance member that does not support inference is called, the type argument must be specified for the member. In these two cases, the syntax for specifying the type argument is different and easily confused.
dotnet_diagnostic.CA1000.severity = error
## CA1051 : Do not declare visible instance fields (category : Design / default: none)
## The primary use of a field should be as an implementation detail. Fields should be private or internal and should be exposed by using properties.
dotnet_diagnostic.CA1051.severity = error
## CA1002 : Do not expose generic lists (category : Design / default: warning)
## System.Collections.Generic.List{T} is a generic collection that's designed for performance and not inheritance. List{T} does not contain virtual members that make it easier to change the behavior of an inherited class.
dotnet_diagnostic.CA1002.severity = none
## CA1061 : Do not hide base class methods (category : Design / default: suggestion)
## A method in a base type is hidden by an identically named method in a derived type when the parameter signature of the derived method differs only by types that are more weakly derived than the corresponding types in the parameter signature of the base method.
dotnet_diagnostic.CA1061.severity = error
## CA1700 : Do not name enum values 'Reserved' (category : Naming / default: warning)
## This rule assumes that an enumeration member that has a name that contains "reserved" is not currently used but is a placeholder to be renamed or removed in a future version. Renaming or removing a member is a breaking change.
dotnet_diagnostic.CA1700.severity = error
## CA1046 : Do not overload equality operator on reference types (category : Design / default: warning)
## For reference types, the default implementation of the equality operator is almost always correct. By default, two references are equal only if they point to the same object. If the operator is providing meaningful value equality, the type should implement the generic 'System.IEquatable' interface.
dotnet_diagnostic.CA1046.severity = error
## CA1045 : Do not pass types by reference (category : Design / default: warning)
## Passing types by reference (using out or ref) requires experience with pointers, understanding how value types and reference types differ, and handling methods that have multiple return values. Also, the difference between out and ref parameters is not widely understood.
dotnet_diagnostic.CA1045.severity = error
## CA1712 : Do not prefix enum values with type name (category : Naming / default: none)
## An enumeration's values should not start with the type name of the enumeration.
dotnet_diagnostic.CA1712.severity = error
## CA1065 : Do not raise exceptions in unexpected locations (category : Design / default: warning)
## A method that is not expected to throw exceptions throws an exception.
dotnet_diagnostic.CA1065.severity = error
## CA1065 : Do not raise exceptions in unexpected locations (category : Design / default: warning)
## A method that is not expected to throw exceptions throws an exception.
dotnet_diagnostic.CA1065.severity = error
## CA1065 : Do not raise exceptions in unexpected locations (category : Design / default: warning)
## A method that is not expected to throw exceptions throws an exception.
dotnet_diagnostic.CA1065.severity = error
## CA1069 : Enums values should not be duplicated (category : Design / default: suggestion)
dotnet_diagnostic.CA1069.severity = error
## CA1069 : Enums values should not be duplicated (category : Design / default: suggestion)
dotnet_diagnostic.CA1069.severity = error
## CA1008 : Enums should have zero value (category : Design / default: warning)
## The default value of an uninitialized enumeration, just as other value types, is zero. A nonflags-attributed enumeration should define a member by using the value of zero so that the default value is a valid value of the enumeration. If an enumeration that has the FlagsAttribute attribute applied defines a zero-valued member, its name should be ""None"" to indicate that no values have been set in the enumeration.
dotnet_diagnostic.CA1008.severity = error
## CA1008 : Enums should have zero value (category : Design / default: warning)
## The default value of an uninitialized enumeration, just as other value types, is zero. A nonflags-attributed enumeration should define a member by using the value of zero so that the default value is a valid value of the enumeration. If an enumeration that has the FlagsAttribute attribute applied defines a zero-valued member, its name should be ""None"" to indicate that no values have been set in the enumeration.
dotnet_diagnostic.CA1008.severity = error
## CA1008 : Enums should have zero value (category : Design / default: warning)
## The default value of an uninitialized enumeration, just as other value types, is zero. A nonflags-attributed enumeration should define a member by using the value of zero so that the default value is a valid value of the enumeration. If an enumeration that has the FlagsAttribute attribute applied defines a zero-valued member, its name should be ""None"" to indicate that no values have been set in the enumeration.
dotnet_diagnostic.CA1008.severity = error
## CA1028 : Enum Storage should be Int32 (category : Design / default: warning)
## An enumeration is a value type that defines a set of related named constants. By default, the System.Int32 data type is used to store the constant value. Although you can change this underlying type, it is not required or recommended for most scenarios.
dotnet_diagnostic.CA1028.severity = error
## CA1027 : Mark enums with FlagsAttribute (category : Design / default: warning)
## An enumeration is a value type that defines a set of related named constants. Apply FlagsAttribute to an enumeration when its named constants can be meaningfully combined.
dotnet_diagnostic.CA1027.severity = error
## CA2217 : Do not mark enums with FlagsAttribute (category : Usage / default: warning)
## An externally visible enumeration is marked by using FlagsAttribute, and it has one or more values that are not powers of two or a combination of the other defined values on the enumeration.
dotnet_diagnostic.CA2217.severity = error
## CA1066 : Implement IEquatable when overriding Object.Equals (category : Design / default: warning)
## When a type T overrides Object.Equals(object), the implementation must cast the object argument to the correct type T before performing the comparison. If the type implements IEquatable{T}, and therefore offers the method T.Equals(T), and if the argument is known at compile time to be of type T, then the compiler can call IEquatable{T}.Equals(T) instead of Object.Equals(object), and no cast is necessary, improving performance.
dotnet_diagnostic.CA1066.severity = error
## CA1067 : Override Object.Equals(object) when implementing IEquatable{T} (category : Design / default: suggestion)
## When a type T implements the interface IEquatable{T}, it suggests to a user who sees a call to the Equals method in source code that an instance of the type can be equated with an instance of any other type. The user might be confused if their attempt to equate the type with an instance of another type fails to compile. This violates the "principle of least surprise".
dotnet_diagnostic.CA1067.severity = error
## CA1713 : Events should not have 'Before' or 'After' prefix (category : Naming / default: warning)
## Event names should describe the action that raises the event. To name related events that are raised in a specific sequence, use the present or past tense to indicate the relative position in the sequence of actions. For example, when naming a pair of events that is raised when closing a resource, you might name it 'Closing' and 'Closed', instead of 'BeforeClose' and 'AfterClose'.
dotnet_diagnostic.CA1713.severity = error
## CA1064 : Exceptions should be public (category : Design / default: warning)
## An internal exception is visible only inside its own internal scope. After the exception falls outside the internal scope, only the base exception can be used to catch the exception. If the internal exception is inherited from T:System.Exception, T:System.SystemException, or T:System.ApplicationException, the external code will not have sufficient information to know what to do with the exception.
dotnet_diagnostic.CA1064.severity = error
## CA1708 : Identifiers should differ by more than case (category : Naming / default: none)
## Identifiers for namespaces, types, members, and parameters cannot differ only by case because languages that target the common language runtime are not required to be case-sensitive.
dotnet_diagnostic.CA1708.severity = error
## CA1715 : Identifiers should have correct prefix (category : Naming / default: none)
## The name of an externally visible interface does not start with an uppercase ""I"". The name of a generic type parameter on an externally visible type or method does not start with an uppercase ""T"".
dotnet_diagnostic.CA1715.severity = error
## CA1715 : Identifiers should have correct prefix (category : Naming / default: none)
## The name of an externally visible interface does not start with an uppercase ""I"". The name of a generic type parameter on an externally visible type or method does not start with an uppercase ""T"".
dotnet_diagnostic.CA1715.severity = error
## CA1710 : Identifiers should have correct suffix (category : Naming / default: none)
## By convention, the names of types that extend certain base types or that implement certain interfaces, or types that are derived from these types, have a suffix that is associated with the base type or interface.
dotnet_diagnostic.CA1710.severity = error
## CA1710 : Identifiers should have correct suffix (category : Naming / default: none)
## By convention, the names of types that extend certain base types or that implement certain interfaces, or types that are derived from these types, have a suffix that is associated with the base type or interface.
dotnet_diagnostic.CA1710.severity = error
## CA1710 : Identifiers should have correct suffix (category : Naming / default: none)
## By convention, the names of types that extend certain base types or that implement certain interfaces, or types that are derived from these types, have a suffix that is associated with the base type or interface.
dotnet_diagnostic.CA1710.severity = error
## CA1720 : Identifier contains type name (category : Naming / default: none)
## Names of parameters and members are better used to communicate their meaning than to describe their type, which is expected to be provided by development tools. For names of members, if a data type name must be used, use a language-independent name instead of a language-specific one.
dotnet_diagnostic.CA1720.severity = error
## CA1711 : Identifiers should not have incorrect suffix (category : Naming / default: none)
## By convention, only the names of types that extend certain base types or that implement certain interfaces, or types that are derived from these types, should end with specific reserved suffixes. Other type names should not use these reserved suffixes.
dotnet_diagnostic.CA1711.severity = error
## CA1711 : Identifiers should not have incorrect suffix (category : Naming / default: none)
## By convention, only the names of types that extend certain base types or that implement certain interfaces, or types that are derived from these types, should end with specific reserved suffixes. Other type names should not use these reserved suffixes.
dotnet_diagnostic.CA1711.severity = error
## CA1711 : Identifiers should not have incorrect suffix (category : Naming / default: none)
## By convention, only the names of types that extend certain base types or that implement certain interfaces, or types that are derived from these types, should end with specific reserved suffixes. Other type names should not use these reserved suffixes.
dotnet_diagnostic.CA1711.severity = error
## CA1711 : Identifiers should not have incorrect suffix (category : Naming / default: none)
## By convention, only the names of types that extend certain base types or that implement certain interfaces, or types that are derived from these types, should end with specific reserved suffixes. Other type names should not use these reserved suffixes.
dotnet_diagnostic.CA1711.severity = error
## CA1716 : Identifiers should not match keywords (category : Naming / default: none)
## A namespace name or a type name matches a reserved keyword in a programming language. Identifiers for namespaces and types should not match keywords that are defined by languages that target the common language runtime.
dotnet_diagnostic.CA1716.severity = error
## CA1716 : Identifiers should not match keywords (category : Naming / default: none)
## A namespace name or a type name matches a reserved keyword in a programming language. Identifiers for namespaces and types should not match keywords that are defined by languages that target the common language runtime.
dotnet_diagnostic.CA1716.severity = error
## CA1716 : Identifiers should not match keywords (category : Naming / default: none)
## A namespace name or a type name matches a reserved keyword in a programming language. Identifiers for namespaces and types should not match keywords that are defined by languages that target the common language runtime.
dotnet_diagnostic.CA1716.severity = error
## CA1716 : Identifiers should not match keywords (category : Naming / default: none)
## A namespace name or a type name matches a reserved keyword in a programming language. Identifiers for namespaces and types should not match keywords that are defined by languages that target the common language runtime.
dotnet_diagnostic.CA1716.severity = error
## CA1063 : Implement IDisposable Correctly (category : Design / default: warning)
## All IDisposable types should implement the Dispose pattern correctly.
dotnet_diagnostic.CA1063.severity = error
## CA1063 : Implement IDisposable Correctly (category : Design / default: warning)
## All IDisposable types should implement the Dispose pattern correctly.
dotnet_diagnostic.CA1063.severity = error
## CA1063 : Implement IDisposable Correctly (category : Design / default: warning)
## All IDisposable types should implement the Dispose pattern correctly.
dotnet_diagnostic.CA1063.severity = error
## CA1063 : Implement IDisposable Correctly (category : Design / default: warning)
## All IDisposable types should implement the Dispose pattern correctly.
dotnet_diagnostic.CA1063.severity = error
## CA1063 : Implement IDisposable Correctly (category : Design / default: warning)
## All IDisposable types should implement the Dispose pattern correctly.
dotnet_diagnostic.CA1063.severity = error
## CA1063 : Implement IDisposable Correctly (category : Design / default: warning)
## All IDisposable types should implement the Dispose pattern correctly.
dotnet_diagnostic.CA1063.severity = error
## CA1063 : Implement IDisposable Correctly (category : Design / default: warning)
## All IDisposable types should implement the Dispose pattern correctly.
dotnet_diagnostic.CA1063.severity = error
## CA1063 : Implement IDisposable Correctly (category : Design / default: warning)
## All IDisposable types should implement the Dispose pattern correctly.
dotnet_diagnostic.CA1063.severity = error
## CA1063 : Implement IDisposable Correctly (category : Design / default: warning)
## All IDisposable types should implement the Dispose pattern correctly.
dotnet_diagnostic.CA1063.severity = error
## CA1033 : Interface methods should be callable by child types (category : Design / default: warning)
## An unsealed externally visible type provides an explicit method implementation of a public interface and does not provide an alternative externally visible method that has the same name.
dotnet_diagnostic.CA1033.severity = error
## CA1016 : Mark assemblies with assembly version (category : Design / default: suggestion)
## The .NET Framework uses the version number to uniquely identify an assembly, and to bind to types in strongly named assemblies. The version number is used together with version and publisher policy. By default, applications run only with the assembly version with which they were built.
dotnet_diagnostic.CA1016.severity = error
## CA1017 : Mark assemblies with ComVisible (category : Design / default: warning)
## ComVisibleAttribute determines how COM clients access managed code. Good design dictates that assemblies explicitly indicate COM visibility. COM visibility can be set for the whole assembly and then overridden for individual types and type members. If this attribute is not present, the contents of the assembly are visible to COM clients.
dotnet_diagnostic.CA1017.severity = error
## CA1017 : Mark assemblies with ComVisible (category : Design / default: warning)
## ComVisibleAttribute determines how COM clients access managed code. Good design dictates that assemblies explicitly indicate COM visibility. COM visibility can be set for the whole assembly and then overridden for individual types and type members. If this attribute is not present, the contents of the assembly are visible to COM clients.
dotnet_diagnostic.CA1017.severity = error
## CA1018 : Mark attributes with AttributeUsageAttribute (category : Design / default: suggestion)
dotnet_diagnostic.CA1018.severity = error
## CA1060 : Move pinvokes to native methods class (category : Design / default: warning)
## Platform Invocation methods, such as those that are marked by using the System.Runtime.InteropServices.DllImportAttribute attribute, or methods that are defined by using the Declare keyword in Visual Basic, access unmanaged code. These methods should be of the NativeMethods, SafeNativeMethods, or UnsafeNativeMethods class.
dotnet_diagnostic.CA1060.severity = error
## CA2211 : Non-constant fields should not be visible (category : Usage / default: suggestion)
## Static fields that are neither constants nor read-only are not thread-safe. Access to such a field must be carefully controlled and requires advanced programming techniques to synchronize access to the class object.
dotnet_diagnostic.CA2211.severity = error
## CA2225 : Operator overloads have named alternates (category : Usage / default: warning)
## An operator overload was detected, and the expected named alternative method was not found. The named alternative member provides access to the same functionality as the operator and is provided for developers who program in languages that do not support overloaded operators.
dotnet_diagnostic.CA2225.severity = suggestion
## CA2226 : Operators should have symmetrical overloads (category : Usage / default: warning)
## A type implements the equality or inequality operator and does not implement the opposite operator.
dotnet_diagnostic.CA2226.severity = error
## CA2231 : Overload operator equals on overriding value type Equals (category : Usage / default: suggestion)
## In most programming languages there is no default implementation of the equality operator (==) for value types. If your programming language supports operator overloads, you should consider implementing the equality operator. Its behavior should be identical to that of Equals.
dotnet_diagnostic.CA2231.severity = error
## CA1815 : Override equals and operator equals on value types (category : Performance / default: warning)
## For value types, the inherited implementation of Equals uses the Reflection library and compares the contents of all fields. Reflection is computationally expensive, and comparing every field for equality might be unnecessary. If you expect users to compare or sort instances, or to use instances as hash table keys, your value type should implement Equals.
dotnet_diagnostic.CA1815.severity = error
## CA1815 : Override equals and operator equals on value types (category : Performance / default: warning)
## For value types, the inherited implementation of Equals uses the Reflection library and compares the contents of all fields. Reflection is computationally expensive, and comparing every field for equality might be unnecessary. If you expect users to compare or sort instances, or to use instances as hash table keys, your value type should implement Equals.
dotnet_diagnostic.CA1815.severity = error
## CA1036 : Override methods on comparable types (category : Design / default: none)
## A public or protected type implements the System.IComparable interface. It does not override Object.Equals nor does it overload the language-specific operator for equality, inequality, less than, less than or equal, greater than or greater than or equal.
dotnet_diagnostic.CA1036.severity = error
## CA1036 : Override methods on comparable types (category : Design / default: none)
## A public or protected type implements the System.IComparable interface. It does not override Object.Equals nor does it overload the language-specific operator for equality, inequality, less than, less than or equal, greater than or greater than or equal.
dotnet_diagnostic.CA1036.severity = error
## CA1036 : Override methods on comparable types (category : Design / default: none)
## A public or protected type implements the System.IComparable interface. It does not override Object.Equals nor does it overload the language-specific operator for equality, inequality, less than, less than or equal, greater than or greater than or equal.
dotnet_diagnostic.CA1036.severity = error
## CA1725 : Parameter names should match base declaration (category : Naming / default: none)
## Consistent naming of parameters in an override hierarchy increases the usability of the method overrides. A parameter name in a derived method that differs from the name in the base declaration can cause confusion about whether the method is an override of the base method or a new overload of the method.
dotnet_diagnostic.CA1725.severity = error
## CA1044 : Properties should not be write only (category : Design / default: warning)
## Although it is acceptable and often necessary to have a read-only property, the design guidelines prohibit the use of write-only properties. This is because letting a user set a value, and then preventing the user from viewing that value, does not provide any security. Also, without read access, the state of shared objects cannot be viewed, which limits their usefulness.
dotnet_diagnostic.CA1044.severity = error
## CA1044 : Properties should not be write only (category : Design / default: warning)
## Although it is acceptable and often necessary to have a read-only property, the design guidelines prohibit the use of write-only properties. This is because letting a user set a value, and then preventing the user from viewing that value, does not provide any security. Also, without read access, the state of shared objects cannot be viewed, which limits their usefulness.
dotnet_diagnostic.CA1044.severity = error
## CA1819 : Properties should not return arrays (category : Performance / default: warning)
## Arrays that are returned by properties are not write-protected, even when the property is read-only. To keep the array tamper-proof, the property must return a copy of the array. Typically, users will not understand the adverse performance implications of calling such a property.
dotnet_diagnostic.CA1819.severity = error
## CA1721 : Property names should not match get methods (category : Naming / default: warning)
## The name of a public or protected member starts with ""Get"" and otherwise matches the name of a public or protected property. ""Get"" methods and properties should have names that clearly distinguish their function.
dotnet_diagnostic.CA1721.severity = error
## CA1041 : Provide ObsoleteAttribute message (category : Design / default: suggestion)
## A type or member is marked by using a System.ObsoleteAttribute attribute that does not have its ObsoleteAttribute.Message property specified. When a type or member that is marked by using ObsoleteAttribute is compiled, the Message property of the attribute is displayed. This gives the user information about the obsolete type or member.
dotnet_diagnostic.CA1041.severity = error
## CA1052 : Static holder types should be Static or NotInheritable (category : Design / default: warning)
dotnet_diagnostic.CA1052.severity = error
## CA1724 : Type names should not match namespaces (category : Naming / default: warning)
## Type names should not match the names of namespaces that are defined in the .NET Framework class library. Violating this rule can reduce the usability of the library.
dotnet_diagnostic.CA1724.severity = error
## CA1724 : Type names should not match namespaces (category : Naming / default: warning)
## Type names should not match the names of namespaces that are defined in the .NET Framework class library. Violating this rule can reduce the usability of the library.
dotnet_diagnostic.CA1724.severity = error
## CA1001 : Types that own disposable fields should be disposable (category : Design / default: none)
## A class declares and implements an instance field that is a System.IDisposable type, and the class does not implement IDisposable. A class that declares an IDisposable field indirectly owns an unmanaged resource and should implement the IDisposable interface.
dotnet_diagnostic.CA1001.severity = error
## CA1054 : URI-like parameters should not be strings (category : Design / default: warning)
## This rule assumes that the parameter represents a Uniform Resource Identifier (URI). A string representation or a URI is prone to parsing and encoding errors, and can lead to security vulnerabilities. 'System.Uri' class provides these services in a safe and secure manner.
dotnet_diagnostic.CA1054.severity = error
## CA1055 : URI-like return values should not be strings (category : Design / default: warning)
## This rule assumes that the method returns a URI. A string representation of a URI is prone to parsing and encoding errors, and can lead to security vulnerabilities. The System.Uri class provides these services in a safe and secure manner.
dotnet_diagnostic.CA1055.severity = error
## CA1030 : Use events where appropriate (category : Design / default: warning)
## This rule detects methods that have names that ordinarily would be used for events. If a method is called in response to a clearly defined state change, the method should be invoked by an event handler. Objects that call the method should raise events instead of calling the method directly.
dotnet_diagnostic.CA1030.severity = error
## CA1003 : Use generic event handler instances (category : Design / default: warning)
## A type contains a delegate that returns void, whose signature contains two parameters (the first an object and the second a type that is assignable to EventArgs), and the containing assembly targets Microsoft .NET Framework?2.0.
dotnet_diagnostic.CA1003.severity = error
## CA1003 : Use generic event handler instances (category : Design / default: warning)
## A delegate that handles a public or protected event does not have the correct signature, return type, or parameter names.
dotnet_diagnostic.CA1003.severity = error
## CA1003 : Use generic event handler instances (category : Design / default: warning)
## A type contains an event that declares an EventHandler delegate that returns void, whose signature contains two parameters (the first an object and the second a type that is assignable to EventArgs), and the containing assembly targets Microsoft .NET Framework?2.0.
dotnet_diagnostic.CA1003.severity = error
## CA1043 : Use Integral Or String Argument For Indexers (category : Design / default: warning)
## Indexers, that is, indexed properties, should use integer or string types for the index. These types are typically used for indexing data structures and increase the usability of the library. Use of the Object type should be restricted to those cases where the specific integer or string type cannot be specified at design time. If the design requires other types for the index, reconsider whether the type represents a logical data store. If it does not represent a logical data store, use a method.
dotnet_diagnostic.CA1043.severity = error
## CA1823 : Avoid unused private fields (category : Performance / default: warning)
## Private fields were detected that do not appear to be accessed in the assembly.
dotnet_diagnostic.CA1823.severity = error
## CA1501 : Avoid excessive inheritance (category : Maintainability / default: warning)
## Deeply nested type hierarchies can be difficult to follow, understand, and maintain. This rule limits analysis to hierarchies in the same module. To fix a violation of this rule, derive the type from a base type that is less deep in the inheritance hierarchy or eliminate some of the intermediate base types.
dotnet_diagnostic.CA1501.severity = error
## CA1502 : Avoid excessive complexity (category : Maintainability / default: warning)
## Cyclomatic complexity measures the number of linearly independent paths through the method, which is determined by the number and complexity of conditional branches. A low cyclomatic complexity generally indicates a method that is easy to understand, test, and maintain. The cyclomatic complexity is calculated from a control flow graph of the method and is given as follows: `cyclomatic complexity = the number of edges - the number of nodes + 1`, where a node represents a logic branch point and an edge represents a line between nodes.
dotnet_diagnostic.CA1502.severity = error
## CA1505 : Avoid unmaintainable code (category : Maintainability / default: warning)
## The maintainability index is calculated by using the following metrics: lines of code, program volume, and cyclomatic complexity. Program volume is a measure of the difficulty of understanding of a symbol that is based on the number of operators and operands in the code. Cyclomatic complexity is a measure of the structural complexity of the type or method. A low maintainability index indicates that code is probably difficult to maintain and would be a good candidate to redesign.
dotnet_diagnostic.CA1505.severity = error
## CA1506 : Avoid excessive class coupling (category : Maintainability / default: warning)
## This rule measures class coupling by counting the number of unique type references that a symbol contains. Symbols that have a high degree of class coupling can be difficult to maintain. It is a good practice to have types and methods that exhibit low coupling and high cohesion. To fix this violation, try to redesign the code to reduce the number of types to which it is coupled.
dotnet_diagnostic.CA1506.severity = error
## CA1509 : Invalid entry in code metrics rule specification file (category : Maintainability / default: warning)
## Invalid entry in code metrics rule specification file.
dotnet_diagnostic.CA1509.severity = error
## CA1806 : Do not ignore method results (category : Performance / default: suggestion)
## A new object is created but never used; or a method that creates and returns a new string is called and the new string is never used; or a COM or P/Invoke method returns an HRESULT or error code that is never used.
dotnet_diagnostic.CA1806.severity = error
## CA1806 : Do not ignore method results (category : Performance / default: suggestion)
## A new object is created but never used; or a method that creates and returns a new string is called and the new string is never used; or a COM or P/Invoke method returns an HRESULT or error code that is never used.
dotnet_diagnostic.CA1806.severity = error
## CA1806 : Do not ignore method results (category : Performance / default: suggestion)
## A new object is created but never used; or a method that creates and returns a new string is called and the new string is never used; or a COM or P/Invoke method returns an HRESULT or error code that is never used.
dotnet_diagnostic.CA1806.severity = error
## CA1806 : Do not ignore method results (category : Performance / default: suggestion)
## A new object is created but never used; or a method that creates and returns a new string is called and the new string is never used; or a COM or P/Invoke method returns an HRESULT or error code that is never used.
dotnet_diagnostic.CA1806.severity = error
## CA1806 : Do not ignore method results (category : Performance / default: suggestion)
## A new object is created but never used; or a method that creates and returns a new string is called and the new string is never used; or a COM or P/Invoke method returns an HRESULT or error code that is never used.
dotnet_diagnostic.CA1806.severity = error
## CA2246 : Assigning symbol and its member in the same statement (category : Usage / default: suggestion)
## Assigning to a symbol and its member (field/property) in the same statement is not recommended. It is not clear if the member access was intended to use symbol's old value prior to the assignment or new value from the assignment in this statement. For clarity, consider splitting the assignments into separate statements.
dotnet_diagnostic.CA2246.severity = error
## CA2244 : Do not duplicate indexed element initializations (category : Usage / default: suggestion)
## Indexed elements in objects initializers must initialize unique elements. A duplicate index might overwrite a previous element initialization.
dotnet_diagnostic.CA2244.severity = error
## CA2011 : Avoid infinite recursion (category : Reliability / default: suggestion)
dotnet_diagnostic.CA2011.severity = error
## CA2011 : Avoid infinite recursion (category : Reliability / default: suggestion)
dotnet_diagnostic.CA2011.severity = error
## CA2245 : Do not assign a property to itself (category : Usage / default: suggestion)
dotnet_diagnostic.CA2245.severity = error
## CA2214 : Do not call overridable methods in constructors (category : Usage / default: warning)
## Virtual methods defined on the class should not be called from constructors. If a derived class has overridden the method, the derived class version will be called (before the derived class constructor is called).
dotnet_diagnostic.CA2214.severity = error
## CA1070 : Do not declare event fields as virtual (category : Design / default: suggestion)
## Do not declare virtual events in a base class. Overridden events in a derived class have undefined behavior. The C# compiler does not handle this correctly and it is unpredictable whether a subscriber to the derived event will actually be subscribing to the base class event.
dotnet_diagnostic.CA1070.severity = error
## CA2219 : Do not raise exceptions in finally clauses (category : Usage / default: suggestion)
## When an exception is raised in a finally clause, the new exception hides the active exception. This makes the original error difficult to detect and debug.
dotnet_diagnostic.CA2219.severity = error
## CA1822 : Mark members as static (category : Performance / default: suggestion)
## Members that do not access instance data or call instance methods can be marked as static. After you mark the methods as static, the compiler will emit nonvirtual call sites to these members. This can give you a measurable performance gain for performance-sensitive code.
dotnet_diagnostic.CA1822.severity = error
## CA1814 : Prefer jagged arrays over multidimensional (category : Performance / default: warning)
## A jagged array is an array whose elements are arrays. The arrays that make up the elements can be of different sizes, leading to less wasted space for some sets of data.
dotnet_diagnostic.CA1814.severity = error
## CA1814 : Prefer jagged arrays over multidimensional (category : Performance / default: warning)
## A jagged array is an array whose elements are arrays. The arrays that make up the elements can be of different sizes, leading to less wasted space for some sets of data.
dotnet_diagnostic.CA1814.severity = error
## CA1814 : Prefer jagged arrays over multidimensional (category : Performance / default: warning)
## A jagged array is an array whose elements are arrays. The arrays that make up the elements can be of different sizes, leading to less wasted space for some sets of data.
dotnet_diagnostic.CA1814.severity = error
## CA1821 : Remove empty Finalizers (category : Performance / default: suggestion)
## Finalizers should be avoided where possible, to avoid the additional performance overhead involved in tracking object lifetime.
dotnet_diagnostic.CA1821.severity = error
## CA2200 : Rethrow to preserve stack details (category : Usage / default: warning)
dotnet_diagnostic.CA2200.severity = error
## CA2119 : Seal methods that satisfy private interfaces (category : Security / default: warning)
## An inheritable public type provides an overridable method implementation of an internal (Friend in Visual Basic) interface. To fix a violation of this rule, prevent the method from being overridden outside the assembly.
dotnet_diagnostic.CA2119.severity = error
## CA2100 : Review SQL queries for security vulnerabilities (category : Security / default: warning)
## SQL queries that directly use user input can be vulnerable to SQL injection attacks. Review this SQL query for potential vulnerabilities, and consider using a parameterized SQL query.
dotnet_diagnostic.CA2100.severity = error
## CA2009 : Do not call ToImmutableCollection on an ImmutableCollection value (category : Reliability / default: suggestion)
dotnet_diagnostic.CA2009.severity = error
## CA1838 : Avoid 'StringBuilder' parameters for P/Invokes (category : Performance / default: none)
## Marshalling of 'StringBuilder' always creates a native buffer copy, resulting in multiple allocations for one marshalling operation.
dotnet_diagnostic.CA1838.severity = error
## CA1420 : Property, type, or attribute requires runtime marshalling (category : Interoperability / default: warning)
## Using features that require runtime marshalling when runtime marshalling is disabled will result in runtime exceptions.
dotnet_diagnostic.CA1420.severity = error
## CA1420 : Property, type, or attribute requires runtime marshalling (category : Interoperability / default: warning)
## Using features that require runtime marshalling when runtime marshalling is disabled will result in runtime exceptions.
dotnet_diagnostic.CA1420.severity = error
## CA1420 : Property, type, or attribute requires runtime marshalling (category : Interoperability / default: warning)
## Using features that require runtime marshalling when runtime marshalling is disabled will result in runtime exceptions.
dotnet_diagnostic.CA1420.severity = error
## CA1420 : Property, type, or attribute requires runtime marshalling (category : Interoperability / default: warning)
## Using features that require runtime marshalling when runtime marshalling is disabled will result in runtime exceptions.
dotnet_diagnostic.CA1420.severity = error
## CA1420 : Property, type, or attribute requires runtime marshalling (category : Interoperability / default: warning)
## Using features that require runtime marshalling when runtime marshalling is disabled will result in runtime exceptions.
dotnet_diagnostic.CA1420.severity = error
## CA1420 : Property, type, or attribute requires runtime marshalling (category : Interoperability / default: warning)
## Using features that require runtime marshalling when runtime marshalling is disabled will result in runtime exceptions.
dotnet_diagnostic.CA1420.severity = error
## CA1420 : Property, type, or attribute requires runtime marshalling (category : Interoperability / default: warning)
## Using features that require runtime marshalling when runtime marshalling is disabled will result in runtime exceptions.
dotnet_diagnostic.CA1420.severity = error
## CA1421 : This method uses runtime marshalling even when the 'DisableRuntimeMarshallingAttribute' is applied (category : Interoperability / default: suggestion)
## This method uses runtime marshalling even when runtime marshalling is disabled, which can cause unexpected behavior differences at runtime due to different expectations of a type's native layout.
dotnet_diagnostic.CA1421.severity = error
## CA1417 : Do not use 'OutAttribute' on string parameters for P/Invokes (category : Interoperability / default: warning)
## String parameters passed by value with the 'OutAttribute' can destabilize the runtime if the string is an interned string.
dotnet_diagnostic.CA1417.severity = error
## CA2258 : Providing a 'DynamicInterfaceCastableImplementation' interface in Visual Basic is unsupported (category : Usage / default: warning)
## Providing a functional 'DynamicInterfaceCastableImplementationAttribute'-attributed interface requires the Default Interface Members feature, which is unsupported in Visual Basic.
dotnet_diagnostic.CA2258.severity = error
## CA2256 : All members declared in parent interfaces must have an implementation in a DynamicInterfaceCastableImplementation-attributed interface (category : Usage / default: warning)
## Types attributed with 'DynamicInterfaceCastableImplementationAttribute' act as an interface implementation for a type that implements the 'IDynamicInterfaceCastable' type. As a result, it must provide an implementation of all of the members defined in the inherited interfaces, because the type that implements 'IDynamicInterfaceCastable' will not provide them otherwise.
dotnet_diagnostic.CA2256.severity = error
## CA2257 : Members defined on an interface with the 'DynamicInterfaceCastableImplementationAttribute' should be 'static' (category : Usage / default: warning)
## Since a type that implements 'IDynamicInterfaceCastable' may not implement a dynamic interface in metadata, calls to an instance interface member that is not an explicit implementation defined on this type are likely to fail at runtime. Mark new interface members 'static' to avoid runtime errors.
dotnet_diagnostic.CA2257.severity = error
## CA1401 : P/Invokes should not be visible (category : Interoperability / default: suggestion)
## A public or protected method in a public type has the System.Runtime.InteropServices.DllImportAttribute attribute (also implemented by the Declare keyword in Visual Basic). Such methods should not be exposed.
dotnet_diagnostic.CA1401.severity = error
## CA2101 : Specify marshaling for P/Invoke string arguments (category : Globalization / default: suggestion)
## A platform invoke member allows partially trusted callers, has a string parameter, and does not explicitly marshal the string. This can cause a potential security vulnerability.
dotnet_diagnostic.CA2101.severity = error
## CA1416 : Validate platform compatibility (category : Interoperability / default: warning)
## Using platform dependent API on a component makes the code no longer work across all platforms.
dotnet_diagnostic.CA1416.severity = error
## CA1416 : Validate platform compatibility (category : Interoperability / default: warning)
## Using platform dependent API on a component makes the code no longer work across all platforms.
dotnet_diagnostic.CA1416.severity = error
## CA1416 : Validate platform compatibility (category : Interoperability / default: warning)
## Using platform dependent API on a component makes the code no longer work across all platforms.
dotnet_diagnostic.CA1416.severity = error
## CA1416 : Validate platform compatibility (category : Interoperability / default: warning)
## Using platform dependent API on a component makes the code no longer work across all platforms.
dotnet_diagnostic.CA1416.severity = error
## CA1416 : Validate platform compatibility (category : Interoperability / default: warning)
## Using platform dependent API on a component makes the code no longer work across all platforms.
dotnet_diagnostic.CA1416.severity = error
## CA1416 : Validate platform compatibility (category : Interoperability / default: warning)
## Using platform dependent API on a component makes the code no longer work across all platforms.
dotnet_diagnostic.CA1416.severity = error
## CA1416 : Validate platform compatibility (category : Interoperability / default: warning)
## Using platform dependent API on a component makes the code no longer work across all platforms.
dotnet_diagnostic.CA1416.severity = error
## CA1422 : Validate platform compatibility (category : Interoperability / default: warning)
## Using platform dependent API on a component makes the code no longer work across all platforms.
dotnet_diagnostic.CA1422.severity = error
## CA1422 : Validate platform compatibility (category : Interoperability / default: warning)
## Using platform dependent API on a component makes the code no longer work across all platforms.
dotnet_diagnostic.CA1422.severity = error
## CA1419 : Provide a parameterless constructor that is as visible as the containing type for concrete types derived from 'System.Runtime.InteropServices.SafeHandle' (category : Interoperability / default: suggestion)
## Providing a parameterless constructor that is as visible as the containing type for a type derived from 'System.Runtime.InteropServices.SafeHandle' enables better performance and usage with source-generated interop solutions.
dotnet_diagnostic.CA1419.severity = error
## CA1418 : Use valid platform string (category : Interoperability / default: warning)
## Platform compatibility analyzer requires a valid platform name and version.
dotnet_diagnostic.CA1418.severity = error
## CA1418 : Use valid platform string (category : Interoperability / default: warning)
## Platform compatibility analyzer requires a valid platform name and version.
dotnet_diagnostic.CA1418.severity = error
## CA1418 : Use valid platform string (category : Interoperability / default: warning)
## Platform compatibility analyzer requires a valid platform name and version.
dotnet_diagnostic.CA1418.severity = error
## CA1869 : Cache and reuse 'JsonSerializerOptions' instances (category : Performance / default: suggestion)
## Avoid creating a new 'JsonSerializerOptions' instance for every serialization operation. Cache and reuse instances instead. Single use 'JsonSerializerOptions' instances can substantially degrade the performance of your application.
dotnet_diagnostic.CA1869.severity = error
## CA1853 : Unnecessary call to 'Dictionary.ContainsKey(key)' (category : Performance / default: suggestion)
## Do not guard 'Dictionary.Remove(key)' with 'Dictionary.ContainsKey(key)'. The former already checks whether the key exists, and will not throw if it does not.
dotnet_diagnostic.CA1853.severity = error
## CA1868 : Unnecessary call to 'Contains(item)' (category : Performance / default: suggestion)
## Do not guard 'Add(item)' or 'Remove(item)' with 'Contains(item)' for the set. The former two already check whether the item exists and will return if it was added or removed.
dotnet_diagnostic.CA1868.severity = error
## CA1854 : Prefer the 'IDictionary.TryGetValue(TKey, out TValue)' method (category : Performance / default: suggestion)
## Prefer a 'TryGetValue' call over a Dictionary indexer access guarded by a 'ContainsKey' check. 'ContainsKey' and the indexer both would lookup the key under the hood, so using 'TryGetValue' removes the extra lookup.
dotnet_diagnostic.CA1854.severity = error
## CA1864 : Prefer the 'IDictionary.TryAdd(TKey, TValue)' method (category : Performance / default: suggestion)
## Prefer a 'TryAdd' call over an 'Add' call guarded by a 'ContainsKey' check. 'TryAdd' behaves the same as 'Add', except that when the specified key already exists, it returns 'false' instead of throwing an exception.
dotnet_diagnostic.CA1864.severity = error
## CA1850 : Prefer static 'HashData' method over 'ComputeHash' (category : Performance / default: suggestion)
## It is more efficient to use the static 'HashData' method over creating and managing a HashAlgorithm instance to call 'ComputeHash'.
dotnet_diagnostic.CA1850.severity = error
## CA1860 : Avoid using 'Enumerable.Any()' extension method (category : Performance / default: suggestion)
## Prefer using 'IsEmpty', 'Count' or 'Length' properties whichever available, rather than calling 'Enumerable.Any()'. The intent is clearer and it is more performant than using 'Enumerable.Any()' extension method.
dotnet_diagnostic.CA1860.severity = error
## CA1860 : Avoid using 'Enumerable.Any()' extension method (category : Performance / default: suggestion)
## Prefer using 'IsEmpty', 'Count' or 'Length' properties whichever available, rather than calling 'Enumerable.Any()'. The intent is clearer and it is more performant than using 'Enumerable.Any()' extension method.
dotnet_diagnostic.CA1860.severity = error
## CA1860 : Avoid using 'Enumerable.Any()' extension method (category : Performance / default: suggestion)
## Prefer using 'IsEmpty', 'Count' or 'Length' properties whichever available, rather than calling 'Enumerable.Any()'. The intent is clearer and it is more performant than using 'Enumerable.Any()' extension method.
dotnet_diagnostic.CA1860.severity = error
## CA1862 : Use the 'StringComparison' method overloads to perform case-insensitive string comparisons (category : Performance / default: suggestion)
## Avoid calling 'ToLower', 'ToUpper', 'ToLowerInvariant' and 'ToUpperInvariant' to perform case-insensitive string comparisons because they lead to an allocation. Instead, prefer calling the method overloads of 'Contains', 'IndexOf' and 'StartsWith' that take a 'StringComparison' enum value to perform case-insensitive comparisons. Switching to using an overload that takes a 'StringComparison' might cause subtle changes in behavior, so it's important to conduct thorough testing after applying the suggestion. Additionally, if a culturally sensitive comparison is not required, consider using 'StringComparison.OrdinalIgnoreCase'.
dotnet_diagnostic.CA1862.severity = error
## CA1862 : Use the 'StringComparison' method overloads to perform case-insensitive string comparisons (category : Performance / default: suggestion)
## Avoid calling 'ToLower', 'ToUpper', 'ToLowerInvariant' and 'ToUpperInvariant' to perform case-insensitive string comparisons when using 'CompareTo', because they lead to an allocation. Instead, use 'StringComparer' to perform case-insensitive comparisons. Switching to using 'StringComparer' might cause subtle changes in behavior, so it's important to conduct thorough testing after applying the suggestion. Additionally, if a culturally sensitive comparison is not required, consider using 'StringComparer.OrdinalIgnoreCase'.
dotnet_diagnostic.CA1862.severity = error
## CA1862 : Use the 'StringComparison' method overloads to perform case-insensitive string comparisons (category : Performance / default: suggestion)
## Avoid calling 'ToLower', 'ToUpper', 'ToLowerInvariant' and 'ToUpperInvariant' to perform case-insensitive string comparisons, as in 'string.ToLower() == string.ToLower()', because they lead to an allocation. Instead, use 'string.Equals(string, StringComparison)' to perform case-insensitive comparisons. Switching to using an overload that takes a 'StringComparison' might cause subtle changes in behavior, so it's important to conduct thorough testing after applying the suggestion. Additionally, if a culturally sensitive comparison is not required, consider using 'StringComparison.OrdinalIgnoreCase'.
dotnet_diagnostic.CA1862.severity = error
## CA1831 : Use AsSpan or AsMemory instead of Range-based indexers when appropriate (category : Performance / default: warning)
## The Range-based indexer on string values produces a copy of requested portion of the string. This copy is usually unnecessary when it is implicitly used as a ReadOnlySpan or ReadOnlyMemory value. Use the AsSpan method to avoid the unnecessary copy.
dotnet_diagnostic.CA1831.severity = error
## CA1832 : Use AsSpan or AsMemory instead of Range-based indexers when appropriate (category : Performance / default: suggestion)
## The Range-based indexer on array values produces a copy of requested portion of the array. This copy is usually unnecessary when it is implicitly used as a ReadOnlySpan or ReadOnlyMemory value. Use the AsSpan method to avoid the unnecessary copy.
dotnet_diagnostic.CA1832.severity = error
## CA1833 : Use AsSpan or AsMemory instead of Range-based indexers when appropriate (category : Performance / default: suggestion)
## The Range-based indexer on array values produces a copy of requested portion of the array. This copy is often unwanted when it is implicitly used as a Span or Memory value. Use the AsSpan method to avoid the copy.
dotnet_diagnostic.CA1833.severity = error
## CA1863 : Use 'CompositeFormat' (category : Performance / default: none)
## Cache and use a 'CompositeFormat' instance as the argument to this formatting operation, rather than passing in the original format string. This reduces the cost of the formatting operation.
dotnet_diagnostic.CA1863.severity = error
## CA1859 : Use concrete types when possible for improved performance (category : Performance / default: suggestion)
## Using concrete types avoids virtual or interface call overhead and enables inlining.
dotnet_diagnostic.CA1859.severity = suggestion
## CA1827 : Do not use Count() or LongCount() when Any() can be used (category : Performance / default: suggestion)
## For non-empty collections, Count() and LongCount() enumerate the entire sequence, while Any() stops at the first item or the first item that satisfies a condition.
dotnet_diagnostic.CA1827.severity = error
## CA1828 : Do not use CountAsync() or LongCountAsync() when AnyAsync() can be used (category : Performance / default: suggestion)
## For non-empty collections, CountAsync() and LongCountAsync() enumerate the entire sequence, while AnyAsync() stops at the first item or the first item that satisfies a condition.
dotnet_diagnostic.CA1828.severity = error
## CA1829 : Use Length/Count property instead of Count() when available (category : Performance / default: suggestion)
## Enumerable.Count() potentially enumerates the sequence while a Length/Count property is a direct access.
dotnet_diagnostic.CA1829.severity = error
## CA1836 : Prefer IsEmpty over Count (category : Performance / default: suggestion)
## For determining whether the object contains or not any items, prefer using 'IsEmpty' property rather than retrieving the number of items from the 'Count' property and comparing it to 0 or 1.
dotnet_diagnostic.CA1836.severity = error
## CA1858 : Use 'StartsWith' instead of 'IndexOf' (category : Performance / default: suggestion)
## It is both clearer and faster to use 'StartsWith' instead of comparing the result of 'IndexOf' to zero.
dotnet_diagnostic.CA1858.severity = error
## CA1847 : Use char literal for a single character lookup (category : Performance / default: suggestion)
## 'string.Contains(char)' is available as a better performing overload for single char lookup.
dotnet_diagnostic.CA1847.severity = error
## CA2243 : Attribute string literals should parse correctly (category : Usage / default: warning)
## The string literal parameter of an attribute does not parse correctly for a URL, a GUID, or a version.
dotnet_diagnostic.CA2243.severity = error
## CA2243 : Attribute string literals should parse correctly (category : Usage / default: warning)
## The string literal parameter of an attribute does not parse correctly for a URL, a GUID, or a version.
dotnet_diagnostic.CA2243.severity = error
## CA1861 : Avoid constant arrays as arguments (category : Performance / default: suggestion)
## Constant arrays passed as arguments are not reused when called repeatedly, which implies a new array is created each time. Consider extracting them to 'static readonly' fields to improve performance if the passed array is not mutated within the called method.
dotnet_diagnostic.CA1861.severity = error
## CA1813 : Avoid unsealed attributes (category : Performance / default: warning)
## The .NET Framework class library provides methods for retrieving custom attributes. By default, these methods search the attribute inheritance hierarchy. Sealing the attribute eliminates the search through the inheritance hierarchy and can improve performance.
dotnet_diagnostic.CA1813.severity = error
## CA2018 : 'Buffer.BlockCopy' expects the number of bytes to be copied for the 'count' argument (category : Reliability / default: warning)
## 'Buffer.BlockCopy' expects the number of bytes to be copied for the 'count' argument. Using 'Array.Length' may not match the number of bytes that needs to be copied.
dotnet_diagnostic.CA2018.severity = error
## CA1816 : Dispose methods should call SuppressFinalize (category : Usage / default: suggestion)
## A method that is an implementation of Dispose does not call GC.SuppressFinalize; or a method that is not an implementation of Dispose calls GC.SuppressFinalize; or a method calls GC.SuppressFinalize and passes something other than this (Me in Visual Basic).
dotnet_diagnostic.CA1816.severity = error
## CA1816 : Dispose methods should call SuppressFinalize (category : Usage / default: suggestion)
## A method that is an implementation of Dispose does not call GC.SuppressFinalize; or a method that is not an implementation of Dispose calls GC.SuppressFinalize; or a method calls GC.SuppressFinalize and passes something other than this (Me in Visual Basic).
dotnet_diagnostic.CA1816.severity = error
## CA1816 : Dispose methods should call SuppressFinalize (category : Usage / default: suggestion)
## A method that is an implementation of Dispose does not call GC.SuppressFinalize; or a method that is not an implementation of Dispose calls GC.SuppressFinalize; or a method calls GC.SuppressFinalize and passes something other than this (Me in Visual Basic).
dotnet_diagnostic.CA1816.severity = error
## CA1816 : Dispose methods should call SuppressFinalize (category : Usage / default: suggestion)
## A method that is an implementation of Dispose does not call GC.SuppressFinalize; or a method that is not an implementation of Dispose calls GC.SuppressFinalize; or a method calls GC.SuppressFinalize and passes something other than this (Me in Visual Basic).
dotnet_diagnostic.CA1816.severity = error
## CA2213 : Disposable fields should be disposed (category : Usage / default: warning)
## A type that implements System.IDisposable declares fields that are of types that also implement IDisposable. The Dispose method of the field is not called by the Dispose method of the declaring type. To fix a violation of this rule, call Dispose on fields that are of types that implement IDisposable if you are responsible for allocating and releasing the unmanaged resources held by the field.
dotnet_diagnostic.CA2213.severity = error
## CA2216 : Disposable types should declare finalizer (category : Usage / default: warning)
## A type that implements System.IDisposable and has fields that suggest the use of unmanaged resources does not implement a finalizer, as described by Object.Finalize.
dotnet_diagnostic.CA2216.severity = error
## CA2215 : Dispose methods should call base class dispose (category : Usage / default: none)
## A type that implements System.IDisposable inherits from a type that also implements IDisposable. The Dispose method of the inheriting type does not call the Dispose method of the parent type. To fix a violation of this rule, call base.Dispose in your Dispose method.
dotnet_diagnostic.CA2215.severity = error
## CA2000 : Dispose objects before losing scope (category : Reliability / default: warning)
## If a disposable object is not explicitly disposed before all references to it are out of scope, the object will be disposed at some indeterminate time when the garbage collector runs the finalizer of the object. Because an exceptional event might occur that will prevent the finalizer of the object from running, the object should be explicitly disposed instead.
dotnet_diagnostic.CA2000.severity = error
## CA2000 : Dispose objects before losing scope (category : Reliability / default: warning)
## If a disposable object is not explicitly disposed before all references to it are out of scope, the object will be disposed at some indeterminate time when the garbage collector runs the finalizer of the object. Because an exceptional event might occur that will prevent the finalizer of the object from running, the object should be explicitly disposed instead.
dotnet_diagnostic.CA2000.severity = error
## CA2000 : Dispose objects before losing scope (category : Reliability / default: warning)
## If a disposable object is not explicitly disposed before all references to it are out of scope, the object will be disposed at some indeterminate time when the garbage collector runs the finalizer of the object. Because an exceptional event might occur that will prevent the finalizer of the object from running, the object should be explicitly disposed instead.
dotnet_diagnostic.CA2000.severity = error
## CA2000 : Dispose objects before losing scope (category : Reliability / default: warning)
## If a disposable object is not explicitly disposed before all references to it are out of scope, the object will be disposed at some indeterminate time when the garbage collector runs the finalizer of the object. Because an exceptional event might occur that will prevent the finalizer of the object from running, the object should be explicitly disposed instead.
dotnet_diagnostic.CA2000.severity = error
## CA2021 : Do not call Enumerable.Cast{T} or Enumerable.OfType{T} with incompatible types (category : Reliability / default: warning)
## Enumerable.Cast{T} and Enumerable.OfType{T} require compatible types to function expectedly.
##  The generic cast (IL 'unbox.any') used by the sequence returned by Enumerable.Cast{T} will throw InvalidCastException at runtime on elements of the types specified.
##  The generic type check (C# 'is' operator/IL 'isinst') used by Enumerable.OfType{T} will never succeed with elements of types specified, resulting in an empty sequence.
##  Widening and user defined conversions are not supported with generic types.
dotnet_diagnostic.CA2021.severity = error
## CA2021 : Do not call Enumerable.Cast{T} or Enumerable.OfType{T} with incompatible types (category : Reliability / default: warning)
## Enumerable.Cast{T} and Enumerable.OfType{T} require compatible types to function expectedly.
##  The generic cast (IL 'unbox.any') used by the sequence returned by Enumerable.Cast{T} will throw InvalidCastException at runtime on elements of the types specified.
##  The generic type check (C# 'is' operator/IL 'isinst') used by Enumerable.OfType{T} will never succeed with elements of types specified, resulting in an empty sequence.
##  Widening and user defined conversions are not supported with generic types.
dotnet_diagnostic.CA2021.severity = error
## CA2015 : Do not define finalizers for types derived from MemoryManager{T} (category : Reliability / default: warning)
## Adding a finalizer to a type derived from MemoryManager{T} may permit memory to be freed while it is still in use by a Span{T}.
dotnet_diagnostic.CA2015.severity = error
## CA2002 : Do not lock on objects with weak identity (category : Reliability / default: warning)
## An object is said to have a weak identity when it can be directly accessed across application domain boundaries. A thread that tries to acquire a lock on an object that has a weak identity can be blocked by a second thread in a different application domain that has a lock on the same object.
dotnet_diagnostic.CA2002.severity = error
## CA1303 : Do not pass literals as localized parameters (category : Globalization / default: warning)
## A method passes a string literal as a parameter to a constructor or method in the .NET Framework class library and that string should be localizable. To fix a violation of this rule, replace the string literal with a string retrieved through an instance of the ResourceManager class.
dotnet_diagnostic.CA1303.severity = error
## CA2201 : Do not raise reserved exception types (category : Usage / default: none)
## An exception of type that is not sufficiently specific or reserved by the runtime should never be raised by user code. This makes the original error difficult to detect and debug. If this exception instance might be thrown, use a different exception type.
dotnet_diagnostic.CA2201.severity = error
## CA2201 : Do not raise reserved exception types (category : Usage / default: none)
## An exception of type that is not sufficiently specific or reserved by the runtime should never be raised by user code. This makes the original error difficult to detect and debug. If this exception instance might be thrown, use a different exception type.
dotnet_diagnostic.CA2201.severity = error
## CA1826 : Do not use Enumerable methods on indexable collections (category : Performance / default: suggestion)
## This collection is directly indexable. Going through LINQ here causes unnecessary allocations and CPU work.
dotnet_diagnostic.CA1826.severity = error
## CA2013 : Do not use ReferenceEquals with value types (category : Reliability / default: warning)
## Value type typed arguments are uniquely boxed for each call to this method, therefore the result can be unexpected.
dotnet_diagnostic.CA2013.severity = error
## CA2013 : Do not use ReferenceEquals with value types (category : Reliability / default: warning)
## Value type typed arguments are uniquely boxed for each call to this method, therefore the result can be unexpected.
dotnet_diagnostic.CA2013.severity = error
## CA1810 : Initialize reference type static fields inline (category : Performance / default: warning)
## A reference type declares an explicit static constructor. To fix a violation of this rule, initialize all static data when it is declared and remove the static constructor.
dotnet_diagnostic.CA1810.severity = error
## CA2207 : Initialize value type static fields inline (category : Usage / default: warning)
## A value type declares an explicit static constructor. To fix a violation of this rule, initialize all static data when it is declared and remove the static constructor.
dotnet_diagnostic.CA2207.severity = error
## CA2208 : Instantiate argument exceptions correctly (category : Usage / default: suggestion)
## A call is made to the default (parameterless) constructor of an exception type that is or derives from ArgumentException, or an incorrect string argument is passed to a parameterized constructor of an exception type that is or derives from ArgumentException.
dotnet_diagnostic.CA2208.severity = error
## CA2208 : Instantiate argument exceptions correctly (category : Usage / default: suggestion)
## A call is made to the default (parameterless) constructor of an exception type that is or derives from ArgumentException, or an incorrect string argument is passed to a parameterized constructor of an exception type that is or derives from ArgumentException.
dotnet_diagnostic.CA2208.severity = error
## CA2208 : Instantiate argument exceptions correctly (category : Usage / default: suggestion)
## A call is made to the default (parameterless) constructor of an exception type that is or derives from ArgumentException, or an incorrect string argument is passed to a parameterized constructor of an exception type that is or derives from ArgumentException.
dotnet_diagnostic.CA2208.severity = error
## CA1727 : Use PascalCase for named placeholders (category : Naming / default: none)
## Use PascalCase for named placeholders in the logging message template.
dotnet_diagnostic.CA1727.severity = error
## CA1848 : Use the LoggerMessage delegates (category : Performance / default: none)
## For improved performance, use the LoggerMessage delegates.
dotnet_diagnostic.CA1848.severity = error
## CA2253 : Named placeholders should not be numeric values (category : Usage / default: suggestion)
## Named placeholders in the logging message template should not be comprised of only numeric characters.
dotnet_diagnostic.CA2253.severity = error
## CA2254 : Template should be a static expression (category : Usage / default: suggestion)
## The logging message template should not vary between calls.
dotnet_diagnostic.CA2254.severity = error
## CA2017 : Parameter count mismatch (category : Reliability / default: warning)
## Number of parameters supplied in the logging message template do not match the number of named placeholders.
dotnet_diagnostic.CA2017.severity = error
## CA2255 : The 'ModuleInitializer' attribute should not be used in libraries (category : Usage / default: warning)
## Module initializers are intended to be used by application code to ensure an application's components are initialized before the application code begins executing. If library code declares a method with the 'ModuleInitializerAttribute', it can interfere with application initialization and also lead to limitations in that application's trimming abilities. Instead of using methods marked with 'ModuleInitializerAttribute', the library should expose methods that can be used to initialize any components within the library and allow the application to invoke the method during application initialization.
dotnet_diagnostic.CA2255.severity = error
## CA1846 : Prefer 'AsSpan' over 'Substring' (category : Performance / default: suggestion)
## 'AsSpan' is more efficient then 'Substring'. 'Substring' performs an O(n) string copy, while 'AsSpan' does not and has a constant cost.
dotnet_diagnostic.CA1846.severity = error
## CA1834 : Consider using 'StringBuilder.Append(char)' when applicable (category : Performance / default: suggestion)
## 'StringBuilder.Append(char)' is more efficient than 'StringBuilder.Append(string)' when the string is a single character. When calling 'Append' with a constant, prefer using a constant char rather than a constant string containing one character.
dotnet_diagnostic.CA1834.severity = error
## CA1835 : Prefer the 'Memory'-based overloads for 'ReadAsync' and 'WriteAsync' (category : Performance / default: suggestion)
## 'Stream' has a 'ReadAsync' overload that takes a 'Memory{Byte}' as the first argument, and a 'WriteAsync' overload that takes a 'ReadOnlyMemory{Byte}' as the first argument. Prefer calling the memory based overloads, which are more efficient.
dotnet_diagnostic.CA1835.severity = error
## CA1835 : Prefer the 'Memory'-based overloads for 'ReadAsync' and 'WriteAsync' (category : Performance / default: suggestion)
## 'Stream' has a 'ReadAsync' overload that takes a 'Memory{Byte}' as the first argument, and a 'WriteAsync' overload that takes a 'ReadOnlyMemory{Byte}' as the first argument. Prefer calling the memory based overloads, which are more efficient.
dotnet_diagnostic.CA1835.severity = error
## CA2249 : Consider using 'string.Contains' instead of 'string.IndexOf' (category : Usage / default: suggestion)
## Calls to 'string.IndexOf' where the result is used to check for the presence/absence of a substring can be replaced by 'string.Contains'.
dotnet_diagnostic.CA2249.severity = error
## CA1830 : Prefer strongly-typed Append and Insert method overloads on StringBuilder (category : Performance / default: suggestion)
## StringBuilder.Append and StringBuilder.Insert provide overloads for multiple types beyond System.String.  When possible, prefer the strongly-typed overloads over using ToString() and the string-based overload.
dotnet_diagnostic.CA1830.severity = error
## CA2241 : Provide correct arguments to formatting methods (category : Usage / default: suggestion)
## The format argument that is passed to System.String.Format does not contain a format item that corresponds to each object argument, or vice versa.
dotnet_diagnostic.CA2241.severity = error
## CA2241 : Provide correct arguments to formatting methods (category : Usage / default: suggestion)
## The format argument that is passed to System.String.Format does not contain a format item that corresponds to each object argument, or vice versa.
dotnet_diagnostic.CA2241.severity = error
## CA1844 : Provide memory-based overrides of async methods when subclassing 'Stream' (category : Performance / default: suggestion)
## To improve performance, override the memory-based async methods when subclassing 'Stream'. Then implement the array-based methods in terms of the memory-based methods.
dotnet_diagnostic.CA1844.severity = error
## CA1852 : Seal internal types (category : Performance / default: none)
## When a type is not accessible outside its assembly and has no subtypes within its containing assembly, it can be safely sealed. Sealing types can improve performance.
dotnet_diagnostic.CA1852.severity = error
## CA2235 : Mark all non-serializable fields (category : Usage / default: warning)
## An instance field of a type that is not serializable is declared in a type that is serializable.
dotnet_diagnostic.CA2235.severity = error
## CA2237 : Mark ISerializable types with serializable (category : Usage / default: warning)
## To be recognized by the common language runtime as serializable, types must be marked by using the SerializableAttribute attribute even when the type uses a custom serialization routine through implementation of the ISerializable interface.
dotnet_diagnostic.CA2237.severity = error
## CA1304 : Specify CultureInfo (category : Globalization / default: none)
## A method or constructor calls a member that has an overload that accepts a System.Globalization.CultureInfo parameter, and the method or constructor does not call the overload that takes the CultureInfo parameter. When a CultureInfo or System.IFormatProvider object is not supplied, the default value that is supplied by the overloaded member might not have the effect that you want in all locales. If the result will be displayed to the user, specify 'CultureInfo.CurrentCulture' as the 'CultureInfo' parameter. Otherwise, if the result will be stored and accessed by software, such as when it is persisted to disk or to a database, specify 'CultureInfo.InvariantCulture'.
dotnet_diagnostic.CA1304.severity = error
## CA1305 : Specify IFormatProvider (category : Globalization / default: none)
## A method or constructor calls one or more members that have overloads that accept a System.IFormatProvider parameter, and the method or constructor does not call the overload that takes the IFormatProvider parameter. When a System.Globalization.CultureInfo or IFormatProvider object is not supplied, the default value that is supplied by the overloaded member might not have the effect that you want in all locales. If the result will be based on the input from/output displayed to the user, specify 'CultureInfo.CurrentCulture' as the 'IFormatProvider'. Otherwise, if the result will be stored and accessed by software, such as when it is loaded from disk/database and when it is persisted to disk/database, specify 'CultureInfo.InvariantCulture'.
dotnet_diagnostic.CA1305.severity = error
## CA1305 : Specify IFormatProvider (category : Globalization / default: none)
## A method or constructor calls one or more members that have overloads that accept a System.IFormatProvider parameter, and the method or constructor does not call the overload that takes the IFormatProvider parameter. When a System.Globalization.CultureInfo or IFormatProvider object is not supplied, the default value that is supplied by the overloaded member might not have the effect that you want in all locales. If the result will be based on the input from/output displayed to the user, specify 'CultureInfo.CurrentCulture' as the 'IFormatProvider'. Otherwise, if the result will be stored and accessed by software, such as when it is loaded from disk/database and when it is persisted to disk/database, specify 'CultureInfo.InvariantCulture'.
dotnet_diagnostic.CA1305.severity = error
## CA1305 : Specify IFormatProvider (category : Globalization / default: none)
## A method or constructor calls one or more members that have overloads that accept a System.IFormatProvider parameter, and the method or constructor does not call the overload that takes the IFormatProvider parameter. When a System.Globalization.CultureInfo or IFormatProvider object is not supplied, the default value that is supplied by the overloaded member might not have the effect that you want in all locales. If the result will be based on the input from/output displayed to the user, specify 'CultureInfo.CurrentCulture' as the 'IFormatProvider'. Otherwise, if the result will be stored and accessed by software, such as when it is loaded from disk/database and when it is persisted to disk/database, specify 'CultureInfo.InvariantCulture'.
dotnet_diagnostic.CA1305.severity = error
## CA1305 : Specify IFormatProvider (category : Globalization / default: none)
## A method or constructor calls one or more members that have overloads that accept a System.IFormatProvider parameter, and the method or constructor does not call the overload that takes the IFormatProvider parameter. When a System.Globalization.CultureInfo or IFormatProvider object is not supplied, the default value that is supplied by the overloaded member might not have the effect that you want in all locales. If the result will be based on the input from/output displayed to the user, specify 'CultureInfo.CurrentCulture' as the 'IFormatProvider'. Otherwise, if the result will be stored and accessed by software, such as when it is loaded from disk/database and when it is persisted to disk/database, specify 'CultureInfo.InvariantCulture'.
dotnet_diagnostic.CA1305.severity = error
## CA1305 : Specify IFormatProvider (category : Globalization / default: none)
## A method or constructor calls one or more members that have overloads that accept a System.IFormatProvider parameter, and the method or constructor does not call the overload that takes the IFormatProvider parameter. When a System.Globalization.CultureInfo or IFormatProvider object is not supplied, the default value that is supplied by the overloaded member might not have the effect that you want in all locales. If the result will be based on the input from/output displayed to the user, specify 'CultureInfo.CurrentCulture' as the 'IFormatProvider'. Otherwise, if the result will be stored and accessed by software, such as when it is loaded from disk/database and when it is persisted to disk/database, specify 'CultureInfo.InvariantCulture'.
dotnet_diagnostic.CA1305.severity = error
## CA1307 : Specify StringComparison for clarity (category : Globalization / default: warning)
## A string comparison operation uses a method overload that does not set a StringComparison parameter. It is recommended to use the overload with StringComparison parameter for clarity of intent. If the result will be displayed to the user, such as when sorting a list of items for display in a list box, specify 'StringComparison.CurrentCulture' or 'StringComparison.CurrentCultureIgnoreCase' as the 'StringComparison' parameter. If comparing case-insensitive identifiers, such as file paths, environment variables, or registry keys and values, specify 'StringComparison.OrdinalIgnoreCase'. Otherwise, if comparing case-sensitive identifiers, specify 'StringComparison.Ordinal'.
dotnet_diagnostic.CA1307.severity = error
## CA1310 : Specify StringComparison for correctness (category : Globalization / default: none)
## A string comparison operation uses a method overload that does not set a StringComparison parameter, hence its behavior could vary based on the current user's locale settings. It is strongly recommended to use the overload with StringComparison parameter for correctness and clarity of intent. If the result will be displayed to the user, such as when sorting a list of items for display in a list box, specify 'StringComparison.CurrentCulture' or 'StringComparison.CurrentCultureIgnoreCase' as the 'StringComparison' parameter. If comparing case-insensitive identifiers, such as file paths, environment variables, or registry keys and values, specify 'StringComparison.OrdinalIgnoreCase'. Otherwise, if comparing case-sensitive identifiers, specify 'StringComparison.Ordinal'.
dotnet_diagnostic.CA1310.severity = error
## CA1820 : Test for empty strings using string length (category : Performance / default: warning)
## Comparing strings by using the String.Length property or the String.IsNullOrEmpty method is significantly faster than using Equals.
dotnet_diagnostic.CA1820.severity = error
## CA2242 : Test for NaN correctly (category : Usage / default: suggestion)
## This expression tests a value against Single.Nan or Double.Nan. Use Single.IsNan(Single) or Double.IsNan(Double) to test the value.
dotnet_diagnostic.CA2242.severity = error
## CA1849 : Call async methods when in an async method (category : Performance / default: warning)
## When inside a Task-returning method, use the async version of methods, if they exist.
dotnet_diagnostic.CA1849.severity = error
## CA1849 : Call async methods when in an async method (category : Performance / default: warning)
## When inside a Task-returning method, use the async version of methods, if they exist.
dotnet_diagnostic.CA1849.severity = error
## CA2250 : Use 'ThrowIfCancellationRequested' (category : Usage / default: suggestion)
## 'ThrowIfCancellationRequested' automatically checks whether the token has been canceled, and throws an 'OperationCanceledException' if it has.
dotnet_diagnostic.CA2250.severity = error
## CA1837 : Use 'Environment.ProcessId' (category : Performance / default: suggestion)
## 'Environment.ProcessId' is simpler and faster than 'Process.GetCurrentProcess().Id'.
dotnet_diagnostic.CA1837.severity = error
## CA1839 : Use 'Environment.ProcessPath' (category : Performance / default: suggestion)
## 'Environment.ProcessPath' is simpler and faster than 'Process.GetCurrentProcess().MainModule.FileName'.
dotnet_diagnostic.CA1839.severity = error
## CA1840 : Use 'Environment.CurrentManagedThreadId' (category : Performance / default: suggestion)
## 'Environment.CurrentManagedThreadId' is simpler and faster than 'Thread.CurrentThread.ManagedThreadId'.
dotnet_diagnostic.CA1840.severity = error
## CA1510 : Use ArgumentNullException throw helper (category : Maintainability / default: suggestion)
## Throw helpers are simpler and more efficient than an if block constructing a new exception instance.
dotnet_diagnostic.CA1510.severity = error
## CA1511 : Use ArgumentException throw helper (category : Maintainability / default: suggestion)
## Throw helpers are simpler and more efficient than an if block constructing a new exception instance.
dotnet_diagnostic.CA1511.severity = error
## CA1512 : Use ArgumentOutOfRangeException throw helper (category : Maintainability / default: suggestion)
## Throw helpers are simpler and more efficient than an if block constructing a new exception instance.
dotnet_diagnostic.CA1512.severity = error
## CA1513 : Use ObjectDisposedException throw helper (category : Maintainability / default: suggestion)
## Throw helpers are simpler and more efficient than an if block constructing a new exception instance.
dotnet_diagnostic.CA1513.severity = error
## CA2251 : Use 'string.Equals' (category : Usage / default: none)
## It is both clearer and likely faster to use 'string.Equals' instead of comparing the result of 'string.Compare' to zero.
dotnet_diagnostic.CA2251.severity = error
## CA2259 : 'ThreadStatic' only affects static fields (category : Usage / default: warning)
## 'ThreadStatic' only affects static fields. When applied to instance fields, it has no impact on behavior.
dotnet_diagnostic.CA2259.severity = error
## CA2019 : Improper 'ThreadStatic' field initialization (category : Reliability / default: suggestion)
## 'ThreadStatic' fields should be initialized lazily on use, not with inline initialization nor explicitly in a static constructor, which would only initialize the field on the thread that runs the type's static constructor.
dotnet_diagnostic.CA2019.severity = error
## CA5358 : Review cipher mode usage with cryptography experts (category : Security / default: warning)
## These cipher modes might be vulnerable to attacks. Consider using recommended modes (CBC, CTS).
dotnet_diagnostic.CA5358.severity = error
## CA5389 : Do Not Add Archive Item's Path To The Target File System Path (category : Security / default: warning)
## When extracting files from an archive and using the archive item's path, check if the path is safe. Archive path can be relative and can lead to file system access outside of the expected file system target path, leading to malicious config changes and remote code execution via lay-and-wait technique.
dotnet_diagnostic.CA5389.severity = error
## CA3061 : Do Not Add Schema By URL (category : Security / default: none)
## This overload of XmlSchemaCollection.Add method internally enables DTD processing on the XML reader instance used, and uses UrlResolver for resolving external XML entities. The outcome is information disclosure. Content from file system or network shares for the machine processing the XML can be exposed to attacker. In addition, an attacker can use this as a DoS vector.
dotnet_diagnostic.CA3061.severity = error
## CA5405 : Do not always skip token validation in delegates (category : Security / default: warning)
## By setting critical TokenValidationParameter validation delegates to true, important authentication safeguards are disabled which can lead to tokens from any issuer or expired tokens being wrongly validated.
dotnet_diagnostic.CA5405.severity = error
## CA5360 : Do Not Call Dangerous Methods In Deserialization (category : Security / default: none)
## Insecure Deserialization is a vulnerability which occurs when untrusted data is used to abuse the logic of an application, inflict a Denial-of-Service (DoS) attack, or even execute arbitrary code upon it being deserialized. It’s frequently possible for malicious users to abuse these deserialization features when the application is deserializing untrusted data which is under their control. Specifically, invoke dangerous methods in the process of deserialization. Successful insecure deserialization attacks could allow an attacker to carry out attacks such as DoS attacks, authentication bypasses, and remote code execution.
dotnet_diagnostic.CA5360.severity = error
## CA5359 : Do Not Disable Certificate Validation (category : Security / default: none)
## A certificate can help authenticate the identity of the server. Clients should validate the server certificate to ensure requests are sent to the intended server. If the ServerCertificateValidationCallback always returns 'true', any certificate will pass validation.
dotnet_diagnostic.CA5359.severity = error
## CA5399 : HttpClients should enable certificate revocation list checks (category : Security / default: warning)
## Using HttpClient without providing a platform specific handler (WinHttpHandler or CurlHandler or HttpClientHandler) where the CheckCertificateRevocationList property is set to true, will allow revoked certificates to be accepted by the HttpClient as valid.
dotnet_diagnostic.CA5399.severity = error
## CA5400 : Ensure HttpClient certificate revocation list check is not disabled (category : Security / default: warning)
## Using HttpClient without providing a platform specific handler (WinHttpHandler or CurlHandler or HttpClientHandler) where the CheckCertificateRevocationList property is set to true, will allow revoked certificates to be accepted by the HttpClient as valid.
dotnet_diagnostic.CA5400.severity = error
## CA5365 : Do Not Disable HTTP Header Checking (category : Security / default: none)
## HTTP header checking enables encoding of the carriage return and newline characters, \r and \n, that are found in response headers. This encoding can help to avoid injection attacks that exploit an application that echoes untrusted data contained by the header.
dotnet_diagnostic.CA5365.severity = error
## CA5363 : Do Not Disable Request Validation (category : Security / default: none)
## Request validation is a feature in ASP.NET that examines HTTP requests and determines whether they contain potentially dangerous content. This check adds protection from markup or code in the URL query string, cookies, or posted form values that might have been added for malicious purposes. So, it is generally desirable and should be left enabled for defense in depth.
dotnet_diagnostic.CA5363.severity = error
## CA5404 : Do not disable token validation checks (category : Security / default: warning)
## Token validation checks ensure that while validating tokens, all aspects are analyzed and verified. Turning off validation can lead to security holes by allowing untrusted tokens to make it through validation.
dotnet_diagnostic.CA5404.severity = error
## CA5403 : Do not hard-code certificate (category : Security / default: warning)
## Hard-coded certificates in source code are vulnerable to being exploited.
dotnet_diagnostic.CA5403.severity = error
## CA5390 : Do not hard-code encryption key (category : Security / default: warning)
## SymmetricAlgorithm's .Key property, or a method's rgbKey parameter, should never be a hard-coded value.
dotnet_diagnostic.CA5390.severity = error
## CA5380 : Do Not Add Certificates To Root Store (category : Security / default: warning)
## By default, the Trusted Root Certification Authorities certificate store is configured with a set of public CAs that has met the requirements of the Microsoft Root Certificate Program. Since all trusted root CAs can issue certificates for any domain, an attacker can pick a weak or coercible CA that you install by yourself to target for an attack - and a single vulnerable, malicious or coercible CA undermines the security of the entire system. To make matters worse, these attacks can go unnoticed quite easily.
dotnet_diagnostic.CA5380.severity = error
## CA5381 : Ensure Certificates Are Not Added To Root Store (category : Security / default: warning)
## By default, the Trusted Root Certification Authorities certificate store is configured with a set of public CAs that has met the requirements of the Microsoft Root Certificate Program. Since all trusted root CAs can issue certificates for any domain, an attacker can pick a weak or coercible CA that you install by yourself to target for an attack - and a single vulnerable, malicious or coercible CA undermines the security of the entire system. To make matters worse, these attacks can go unnoticed quite easily.
dotnet_diagnostic.CA5381.severity = error
## CA5367 : Do Not Serialize Types With Pointer Fields (category : Security / default: warning)
## Pointers are not "type safe" in the sense that you cannot guarantee the correctness of the memory they point at. So, serializing types with pointer fields is dangerous, as it may allow an attacker to control the pointer.
dotnet_diagnostic.CA5367.severity = error
## CA5361 : Do Not Disable SChannel Use of Strong Crypto (category : Security / default: warning)
## Starting with the .NET Framework 4.6, the System.Net.ServicePointManager and System.Net.Security.SslStream classes are recommended to use new protocols. The old ones have protocol weaknesses and are not supported. Setting Switch.System.Net.DontEnableSchUseStrongCrypto with true will use the old weak crypto check and opt out of the protocol migration.
dotnet_diagnostic.CA5361.severity = error
## CA5378 : Do not disable ServicePointManagerSecurityProtocols (category : Security / default: warning)
dotnet_diagnostic.CA5378.severity = error
## CA5375 : Do Not Use Account Shared Access Signature (category : Security / default: warning)
## Shared Access Signatures(SAS) are a vital part of the security model for any application using Azure Storage, they should provide limited and safe permissions to your storage account to clients that don't have the account key. All of the operations available via a service SAS are also available via an account SAS, that is, account SAS is too powerful. So it is recommended to use Service SAS to delegate access more carefully.
dotnet_diagnostic.CA5375.severity = error
## CA5401 : Do not use CreateEncryptor with non-default IV (category : Security / default: warning)
## Symmetric encryption should always use a non-repeatable initialization vector to prevent dictionary attacks.
dotnet_diagnostic.CA5401.severity = error
## CA5402 : Use CreateEncryptor with the default IV  (category : Security / default: warning)
## Symmetric encryption should always use a non-repeatable initialization vector to prevent dictionary attacks.
dotnet_diagnostic.CA5402.severity = error
## CA2351 : Do not use DataSet.ReadXml() with untrusted data (category : Security / default: warning)
dotnet_diagnostic.CA2351.severity = error
## CA2361 : Ensure auto-generated class containing DataSet.ReadXml() is not used with untrusted data (category : Security / default: warning)
dotnet_diagnostic.CA2361.severity = error
## CA2350 : Do not use DataTable.ReadXml() with untrusted data (category : Security / default: warning)
dotnet_diagnostic.CA2350.severity = error
## CA5364 : Do Not Use Deprecated Security Protocols (category : Security / default: none)
## Using a deprecated security protocol rather than the system default is risky.
dotnet_diagnostic.CA5364.severity = error
## CA5386 : Avoid hardcoding SecurityProtocolType value (category : Security / default: warning)
dotnet_diagnostic.CA5386.severity = error
## CA5384 : Do Not Use Digital Signature Algorithm (DSA) (category : Security / default: none)
## DSA is too weak to use.
dotnet_diagnostic.CA5384.severity = error
## CA5351 : Do Not Use Broken Cryptographic Algorithms (category : Security / default: none)
## An attack making it computationally feasible to break this algorithm exists. This allows attackers to break the cryptographic guarantees it is designed to provide. Depending on the type and application of this cryptographic algorithm, this may allow attackers to read enciphered messages, tamper with enciphered  messages, forge digital signatures, tamper with hashed content, or otherwise compromise any cryptosystem based on this algorithm. Replace encryption uses with the AES algorithm (AES-256, AES-192 and AES-128 are acceptable) with a key length greater than or equal to 128 bits. Replace hashing uses with a hashing function in the SHA-2 family, such as SHA512, SHA384, or SHA256. Replace digital signature uses with RSA with a key length greater than or equal to 2048-bits, or ECDSA with a key length greater than or equal to 256 bits.
dotnet_diagnostic.CA5351.severity = error
## CA5350 : Do Not Use Weak Cryptographic Algorithms (category : Security / default: none)
## Cryptographic algorithms degrade over time as attacks become for advances to attacker get access to more computation. Depending on the type and application of this cryptographic algorithm, further degradation of the cryptographic strength of it may allow attackers to read enciphered messages, tamper with enciphered  messages, forge digital signatures, tamper with hashed content, or otherwise compromise any cryptosystem based on this algorithm. Replace encryption uses with the AES algorithm (AES-256, AES-192 and AES-128 are acceptable) with a key length greater than or equal to 128 bits. Replace hashing uses with a hashing function in the SHA-2 family, such as SHA-2 512, SHA-2 384, or SHA-2 256.
dotnet_diagnostic.CA5350.severity = error
## CA2300 : Do not use insecure deserializer BinaryFormatter (category : Security / default: warning)
## The method '{0}' is insecure when deserializing untrusted data.  If you need to instead detect BinaryFormatter deserialization without a SerializationBinder set, then disable rule CA2300, and enable rules CA2301 and CA2302.
dotnet_diagnostic.CA2300.severity = error
## CA2301 : Do not call BinaryFormatter.Deserialize without first setting BinaryFormatter.Binder (category : Security / default: warning)
dotnet_diagnostic.CA2301.severity = error
## CA2302 : Ensure BinaryFormatter.Binder is set before calling BinaryFormatter.Deserialize (category : Security / default: warning)
dotnet_diagnostic.CA2302.severity = error
## CA2321 : Do not deserialize with JavaScriptSerializer using a SimpleTypeResolver (category : Security / default: warning)
dotnet_diagnostic.CA2321.severity = error
## CA2322 : Ensure JavaScriptSerializer is not initialized with SimpleTypeResolver before deserializing (category : Security / default: warning)
dotnet_diagnostic.CA2322.severity = error
## CA2329 : Do not deserialize with JsonSerializer using an insecure configuration (category : Security / default: warning)
dotnet_diagnostic.CA2329.severity = error
## CA2330 : Ensure that JsonSerializer has a secure configuration when deserializing (category : Security / default: warning)
dotnet_diagnostic.CA2330.severity = error
## CA2305 : Do not use insecure deserializer LosFormatter (category : Security / default: warning)
dotnet_diagnostic.CA2305.severity = error
## CA2310 : Do not use insecure deserializer NetDataContractSerializer (category : Security / default: warning)
## The method '{0}' is insecure when deserializing untrusted data.  If you need to instead detect NetDataContractSerializer deserialization without a SerializationBinder set, then disable rule CA2310, and enable rules CA2311 and CA2312.
dotnet_diagnostic.CA2310.severity = error
## CA2311 : Do not deserialize without first setting NetDataContractSerializer.Binder (category : Security / default: warning)
dotnet_diagnostic.CA2311.severity = error
## CA2312 : Ensure NetDataContractSerializer.Binder is set before deserializing (category : Security / default: warning)
dotnet_diagnostic.CA2312.severity = error
## CA2315 : Do not use insecure deserializer ObjectStateFormatter (category : Security / default: warning)
dotnet_diagnostic.CA2315.severity = error
## CA5394 : Do not use insecure randomness (category : Security / default: warning)
## Using a cryptographically weak pseudo-random number generator may allow an attacker to predict what security-sensitive value will be generated. Use a cryptographically strong random number generator if an unpredictable value is required, or ensure that weak pseudo-random numbers aren't used in a security-sensitive manner.
dotnet_diagnostic.CA5394.severity = error
## CA2327 : Do not use insecure JsonSerializerSettings (category : Security / default: warning)
dotnet_diagnostic.CA2327.severity = error
## CA2328 : Ensure that JsonSerializerSettings are secure (category : Security / default: warning)
dotnet_diagnostic.CA2328.severity = error
## CA5373 : Do not use obsolete key derivation function (category : Security / default: none)
## Password-based key derivation should use PBKDF2 with SHA-2. Avoid using PasswordDeriveBytes since it generates a PBKDF1 key. Avoid using Rfc2898DeriveBytes.CryptDeriveKey since it doesn't use the iteration count or salt.
dotnet_diagnostic.CA5373.severity = error
## CA5379 : Ensure Key Derivation Function algorithm is sufficiently strong (category : Security / default: none)
## Some implementations of the Rfc2898DeriveBytes class allow for a hash algorithm to be specified in a constructor parameter or overwritten in the HashAlgorithm property. If a hash algorithm is specified, then it should be SHA-256 or higher.
dotnet_diagnostic.CA5379.severity = error
## CA5387 : Do Not Use Weak Key Derivation Function With Insufficient Iteration Count (category : Security / default: warning)
## When deriving cryptographic keys from user-provided inputs such as password, use sufficient iteration count (at least 100k).
dotnet_diagnostic.CA5387.severity = error
## CA5388 : Ensure Sufficient Iteration Count When Using Weak Key Derivation Function (category : Security / default: warning)
## When deriving cryptographic keys from user-provided inputs such as password, use sufficient iteration count (at least 100k).
dotnet_diagnostic.CA5388.severity = error
## CA5374 : Do Not Use XslTransform (category : Security / default: none)
dotnet_diagnostic.CA5374.severity = error
## CA2326 : Do not use TypeNameHandling values other than None (category : Security / default: warning)
## Deserializing JSON when using a TypeNameHandling value other than None can be insecure.  If you need to instead detect Json.NET deserialization when a SerializationBinder isn't specified, then disable rule CA2326, and enable rules CA2327, CA2328, CA2329, and CA2330.
dotnet_diagnostic.CA2326.severity = error
## CA5362 : Potential reference cycle in deserialized object graph (category : Security / default: warning)
## Review code that processes untrusted deserialized data for handling of unexpected reference cycles. An unexpected reference cycle should not cause the code to enter an infinite loop. Otherwise, an unexpected reference cycle can allow an attacker to DOS or exhaust the memory of the process when deserializing untrusted data.
dotnet_diagnostic.CA5362.severity = error
## CA3006 : Review code for process command injection vulnerabilities (category : Security / default: warning)
dotnet_diagnostic.CA3006.severity = error
## CA3011 : Review code for DLL injection vulnerabilities (category : Security / default: warning)
dotnet_diagnostic.CA3011.severity = error
## CA3003 : Review code for file path injection vulnerabilities (category : Security / default: warning)
dotnet_diagnostic.CA3003.severity = error
## CA3004 : Review code for information disclosure vulnerabilities (category : Security / default: warning)
dotnet_diagnostic.CA3004.severity = error
## CA3005 : Review code for LDAP injection vulnerabilities (category : Security / default: warning)
dotnet_diagnostic.CA3005.severity = error
## CA3007 : Review code for open redirect vulnerabilities (category : Security / default: warning)
dotnet_diagnostic.CA3007.severity = error
## CA3012 : Review code for regex injection vulnerabilities (category : Security / default: warning)
dotnet_diagnostic.CA3012.severity = error
## CA3001 : Review code for SQL injection vulnerabilities (category : Security / default: warning)
dotnet_diagnostic.CA3001.severity = error
## CA3010 : Review code for XAML injection vulnerabilities (category : Security / default: warning)
dotnet_diagnostic.CA3010.severity = error
## CA3009 : Review code for XML injection vulnerabilities (category : Security / default: warning)
dotnet_diagnostic.CA3009.severity = error
## CA3008 : Review code for XPath injection vulnerabilities (category : Security / default: warning)
dotnet_diagnostic.CA3008.severity = error
## CA3002 : Review code for XSS vulnerabilities (category : Security / default: warning)
dotnet_diagnostic.CA3002.severity = error
## CA5396 : Set HttpOnly to true for HttpCookie (category : Security / default: warning)
## As a defense in depth measure, ensure security sensitive HTTP cookies are marked as HttpOnly. This indicates web browsers should disallow scripts from accessing the cookies. Injected malicious scripts are a common way of stealing cookies.
dotnet_diagnostic.CA5396.severity = error
## CA5368 : Set ViewStateUserKey For Classes Derived From Page (category : Security / default: none)
## Setting the ViewStateUserKey property can help you prevent attacks on your application by allowing you to assign an identifier to the view-state variable for individual users so that they cannot use the variable to generate an attack. Otherwise, there will be cross-site request forgery vulnerabilities.
dotnet_diagnostic.CA5368.severity = error
## CA5397 : Do not use deprecated SslProtocols values (category : Security / default: none)
## Older protocol versions of Transport Layer Security (TLS) are less secure than TLS 1.2 and TLS 1.3, and are more likely to have new vulnerabilities. Avoid older protocol versions to minimize risk.
dotnet_diagnostic.CA5397.severity = error
## CA5398 : Avoid hardcoded SslProtocols values (category : Security / default: warning)
## Current Transport Layer Security protocol versions may become deprecated if vulnerabilities are found. Avoid hardcoding SslProtocols values to keep your application secure. Use 'None' to let the Operating System choose a version.
dotnet_diagnostic.CA5398.severity = error
## CA5391 : Use antiforgery tokens in ASP.NET Core MVC controllers (category : Security / default: warning)
## Handling a POST, PUT, PATCH, or DELETE request without validating an antiforgery token may be vulnerable to cross-site request forgery attacks. A cross-site request forgery attack can send malicious requests from an authenticated user to your ASP.NET Core MVC controller.
dotnet_diagnostic.CA5391.severity = error
## CA5395 : Miss HttpVerb attribute for action methods (category : Security / default: warning)
## All the methods that create, edit, delete, or otherwise modify data do so in the [HttpPost] overload of the method, which needs to be protected with the anti forgery attribute from request forgery. Performing a GET operation should be a safe operation that has no side effects and doesn't modify your persisted data.
dotnet_diagnostic.CA5395.severity = error
## CA5377 : Use Container Level Access Policy (category : Security / default: warning)
## No access policy identifier is specified, making tokens non-revocable.
dotnet_diagnostic.CA5377.severity = error
## CA5392 : Use DefaultDllImportSearchPaths attribute for P/Invokes (category : Security / default: warning)
## By default, P/Invokes using DllImportAttribute probe a number of directories, including the current working directory for the library to load. This can be a security issue for certain applications, leading to DLL hijacking.
dotnet_diagnostic.CA5392.severity = error
## CA5393 : Do not use unsafe DllImportSearchPath value (category : Security / default: warning)
## There could be a malicious DLL in the default DLL search directories. Or, depending on where your application is run from, there could be a malicious DLL in the application's directory. Use a DllImportSearchPath value that specifies an explicit search path instead. The DllImportSearchPath flags that this rule looks for can be configured in .editorconfig.
dotnet_diagnostic.CA5393.severity = error
## CA5385 : Use Rivest-Shamir-Adleman (RSA) Algorithm With Sufficient Key Size (category : Security / default: none)
## Encryption algorithms are vulnerable to brute force attacks when too small a key size is used.
dotnet_diagnostic.CA5385.severity = error
## CA5382 : Use Secure Cookies In ASP.NET Core (category : Security / default: warning)
## Applications available over HTTPS must use secure cookies.
dotnet_diagnostic.CA5382.severity = error
## CA5383 : Ensure Use Secure Cookies In ASP.NET Core (category : Security / default: warning)
## Applications available over HTTPS must use secure cookies.
dotnet_diagnostic.CA5383.severity = error
## CA5376 : Use SharedAccessProtocol HttpsOnly (category : Security / default: warning)
## HTTPS encrypts network traffic. Use HttpsOnly, rather than HttpOrHttps, to ensure network traffic is always encrypted to help prevent disclosure of sensitive data.
dotnet_diagnostic.CA5376.severity = error
## CA5366 : Use XmlReader for 'DataSet.ReadXml()' (category : Security / default: none)
## Processing XML from untrusted data may load dangerous external references, which should be restricted by using an XmlReader with a secure resolver or with DTD processing disabled.
dotnet_diagnostic.CA5366.severity = error
## CA5369 : Use XmlReader for 'XmlSerializer.Deserialize()' (category : Security / default: none)
## Processing XML from untrusted data may load dangerous external references, which should be restricted by using an XmlReader with a secure resolver or with DTD processing disabled.
dotnet_diagnostic.CA5369.severity = error
## CA5371 : Use XmlReader for 'XmlSchema.Read()' (category : Security / default: none)
## Processing XML from untrusted data may load dangerous external references, which should be restricted by using an XmlReader with a secure resolver or with DTD processing disabled.
dotnet_diagnostic.CA5371.severity = error
## CA5370 : Use XmlReader for XmlValidatingReader constructor (category : Security / default: none)
## Processing XML from untrusted data may load dangerous external references, which should be restricted by using an XmlReader with a secure resolver or with DTD processing disabled.
dotnet_diagnostic.CA5370.severity = error
## CA5372 : Use XmlReader for XPathDocument constructor (category : Security / default: none)
## Processing XML from untrusted data may load dangerous external references, which should be restricted by using an XmlReader with a secure resolver or with DTD processing disabled.
dotnet_diagnostic.CA5372.severity = error
## CA2247 : Argument passed to TaskCompletionSource constructor should be TaskCreationOptions enum instead of TaskContinuationOptions enum (category : Usage / default: warning)
## TaskCompletionSource has constructors that take TaskCreationOptions that control the underlying Task, and constructors that take object state that's stored in the task.  Accidentally passing a TaskContinuationOptions instead of a TaskCreationOptions will result in the call treating the options as state.
dotnet_diagnostic.CA2247.severity = error
## CA2008 : Do not create tasks without passing a TaskScheduler (category : Reliability / default: warning)
## Do not create tasks unless you are using one of the overloads that takes a TaskScheduler. The default is to schedule on TaskScheduler.Current, which would lead to deadlocks. Either use TaskScheduler.Default to schedule on the thread pool, or explicitly pass TaskScheduler.Current to make your intentions clear.
dotnet_diagnostic.CA2008.severity = error
## CA2261 : Do not use ConfigureAwaitOptions.SuppressThrowing with Task{TResult} (category : Usage / default: warning)
## The ConfigureAwaitOptions.SuppressThrowing is only supported with the non-generic Task, not a Task{TResult}.  To use it with a Task{TResult}, first cast to the base Task.
dotnet_diagnostic.CA2261.severity = error
## CA1842 : Do not use 'WhenAll' with a single task (category : Performance / default: suggestion)
## Using 'WhenAll' with a single task may result in performance loss, await or return the task instead.
dotnet_diagnostic.CA1842.severity = error
## CA1843 : Do not use 'WaitAll' with a single task (category : Performance / default: suggestion)
## Using 'WaitAll' with a single task may result in performance loss, await or return the task instead.
dotnet_diagnostic.CA1843.severity = error
## CA2012 : Use ValueTasks correctly (category : Reliability / default: suggestion)
## ValueTasks returned from member invocations are intended to be directly awaited.  Attempts to consume a ValueTask multiple times or to directly access one's result before it's known to be completed may result in an exception or corruption.  Ignoring such a ValueTask is likely an indication of a functional bug and may degrade performance.
dotnet_diagnostic.CA2012.severity = error
## CA2012 : Use ValueTasks correctly (category : Reliability / default: suggestion)
## ValueTasks returned from member invocations are intended to be directly awaited.  Attempts to consume a ValueTask multiple times or to directly access one's result before it's known to be completed may result in an exception or corruption.  Ignoring such a ValueTask is likely an indication of a functional bug and may degrade performance.
dotnet_diagnostic.CA2012.severity = error
## CA2012 : Use ValueTasks correctly (category : Reliability / default: suggestion)
## ValueTasks returned from member invocations are intended to be directly awaited.  Attempts to consume a ValueTask multiple times or to directly access one's result before it's known to be completed may result in an exception or corruption.  Ignoring such a ValueTask is likely an indication of a functional bug and may degrade performance.
dotnet_diagnostic.CA2012.severity = error
## CA2012 : Use ValueTasks correctly (category : Reliability / default: suggestion)
## ValueTasks returned from member invocations are intended to be directly awaited.  Attempts to consume a ValueTask multiple times or to directly access one's result before it's known to be completed may result in an exception or corruption.  Ignoring such a ValueTask is likely an indication of a functional bug and may degrade performance.
dotnet_diagnostic.CA2012.severity = error
## CA2248 : Provide correct 'enum' argument to 'Enum.HasFlag' (category : Usage / default: suggestion)
## 'Enum.HasFlag' method expects the 'enum' argument to be of the same 'enum' type as the instance on which the method is invoked and that this 'enum' is marked with 'System.FlagsAttribute'. If these are different 'enum' types, an unhandled exception will be thrown at runtime. If the 'enum' type is not marked with 'System.FlagsAttribute' the call will always return 'false' at runtime.
dotnet_diagnostic.CA2248.severity = error
## CA2153 : Do Not Catch Corrupted State Exceptions (category : Security / default: warning)
## Catching corrupted state exceptions could mask errors (such as access violations), resulting in inconsistent state of execution or making it easier for attackers to compromise system. Instead, catch and handle a more specific set of exception type(s) or re-throw the exception.
dotnet_diagnostic.CA2153.severity = error
## CA3075 : Insecure DTD processing in XML (category : Security / default: none)
## Using XmlTextReader.Load(), creating an insecure XmlReaderSettings instance when invoking XmlReader.Create(), setting the InnerXml property of the XmlDocument and enabling DTD processing using XmlUrlResolver insecurely can lead to information disclosure. Replace it with a call to the Load() method overload that takes an XmlReader instance, use XmlReader.Create() to accept XmlReaderSettings arguments or consider explicitly setting secure values. The DataViewSettingCollectionString property of DataViewManager should always be assigned from a trusted source, the DtdProcessing property should be set to false, and the XmlResolver property should be changed to XmlSecureResolver or null.
dotnet_diagnostic.CA3075.severity = error
## CA3075 : Insecure DTD processing in XML (category : Security / default: none)
## Using XmlTextReader.Load(), creating an insecure XmlReaderSettings instance when invoking XmlReader.Create(), setting the InnerXml property of the XmlDocument and enabling DTD processing using XmlUrlResolver insecurely can lead to information disclosure. Replace it with a call to the Load() method overload that takes an XmlReader instance, use XmlReader.Create() to accept XmlReaderSettings arguments or consider explicitly setting secure values. The DataViewSettingCollectionString property of DataViewManager should always be assigned from a trusted source, the DtdProcessing property should be set to false, and the XmlResolver property should be changed to XmlSecureResolver or null.
dotnet_diagnostic.CA3075.severity = error
## CA3075 : Insecure DTD processing in XML (category : Security / default: none)
## Using XmlTextReader.Load(), creating an insecure XmlReaderSettings instance when invoking XmlReader.Create(), setting the InnerXml property of the XmlDocument and enabling DTD processing using XmlUrlResolver insecurely can lead to information disclosure. Replace it with a call to the Load() method overload that takes an XmlReader instance, use XmlReader.Create() to accept XmlReaderSettings arguments or consider explicitly setting secure values. The DataViewSettingCollectionString property of DataViewManager should always be assigned from a trusted source, the DtdProcessing property should be set to false, and the XmlResolver property should be changed to XmlSecureResolver or null.
dotnet_diagnostic.CA3075.severity = error
## CA3075 : Insecure DTD processing in XML (category : Security / default: none)
## Using XmlTextReader.Load(), creating an insecure XmlReaderSettings instance when invoking XmlReader.Create(), setting the InnerXml property of the XmlDocument and enabling DTD processing using XmlUrlResolver insecurely can lead to information disclosure. Replace it with a call to the Load() method overload that takes an XmlReader instance, use XmlReader.Create() to accept XmlReaderSettings arguments or consider explicitly setting secure values. The DataViewSettingCollectionString property of DataViewManager should always be assigned from a trusted source, the DtdProcessing property should be set to false, and the XmlResolver property should be changed to XmlSecureResolver or null.
dotnet_diagnostic.CA3075.severity = error
## CA3075 : Insecure DTD processing in XML (category : Security / default: none)
## Using XmlTextReader.Load(), creating an insecure XmlReaderSettings instance when invoking XmlReader.Create(), setting the InnerXml property of the XmlDocument and enabling DTD processing using XmlUrlResolver insecurely can lead to information disclosure. Replace it with a call to the Load() method overload that takes an XmlReader instance, use XmlReader.Create() to accept XmlReaderSettings arguments or consider explicitly setting secure values. The DataViewSettingCollectionString property of DataViewManager should always be assigned from a trusted source, the DtdProcessing property should be set to false, and the XmlResolver property should be changed to XmlSecureResolver or null.
dotnet_diagnostic.CA3075.severity = error
## CA3075 : Insecure DTD processing in XML (category : Security / default: none)
## Using XmlTextReader.Load(), creating an insecure XmlReaderSettings instance when invoking XmlReader.Create(), setting the InnerXml property of the XmlDocument and enabling DTD processing using XmlUrlResolver insecurely can lead to information disclosure. Replace it with a call to the Load() method overload that takes an XmlReader instance, use XmlReader.Create() to accept XmlReaderSettings arguments or consider explicitly setting secure values. The DataViewSettingCollectionString property of DataViewManager should always be assigned from a trusted source, the DtdProcessing property should be set to false, and the XmlResolver property should be changed to XmlSecureResolver or null.
dotnet_diagnostic.CA3075.severity = error
## CA3075 : Insecure DTD processing in XML (category : Security / default: none)
## Using XmlTextReader.Load(), creating an insecure XmlReaderSettings instance when invoking XmlReader.Create(), setting the InnerXml property of the XmlDocument and enabling DTD processing using XmlUrlResolver insecurely can lead to information disclosure. Replace it with a call to the Load() method overload that takes an XmlReader instance, use XmlReader.Create() to accept XmlReaderSettings arguments or consider explicitly setting secure values. The DataViewSettingCollectionString property of DataViewManager should always be assigned from a trusted source, the DtdProcessing property should be set to false, and the XmlResolver property should be changed to XmlSecureResolver or null.
dotnet_diagnostic.CA3075.severity = error
## CA3075 : Insecure DTD processing in XML (category : Security / default: none)
## Using XmlTextReader.Load(), creating an insecure XmlReaderSettings instance when invoking XmlReader.Create(), setting the InnerXml property of the XmlDocument and enabling DTD processing using XmlUrlResolver insecurely can lead to information disclosure. Replace it with a call to the Load() method overload that takes an XmlReader instance, use XmlReader.Create() to accept XmlReaderSettings arguments or consider explicitly setting secure values. The DataViewSettingCollectionString property of DataViewManager should always be assigned from a trusted source, the DtdProcessing property should be set to false, and the XmlResolver property should be changed to XmlSecureResolver or null.
dotnet_diagnostic.CA3075.severity = error
## CA3075 : Insecure DTD processing in XML (category : Security / default: none)
## Using XmlTextReader.Load(), creating an insecure XmlReaderSettings instance when invoking XmlReader.Create(), setting the InnerXml property of the XmlDocument and enabling DTD processing using XmlUrlResolver insecurely can lead to information disclosure. Replace it with a call to the Load() method overload that takes an XmlReader instance, use XmlReader.Create() to accept XmlReaderSettings arguments or consider explicitly setting secure values. The DataViewSettingCollectionString property of DataViewManager should always be assigned from a trusted source, the DtdProcessing property should be set to false, and the XmlResolver property should be changed to XmlSecureResolver or null.
dotnet_diagnostic.CA3075.severity = error
## CA3077 : Insecure Processing in API Design, XmlDocument and XmlTextReader (category : Security / default: none)
## Enabling DTD processing on all instances derived from XmlTextReader or  XmlDocument and using XmlUrlResolver for resolving external XML entities may lead to information disclosure. Ensure to set the XmlResolver property to null, create an instance of XmlSecureResolver when processing untrusted input, or use XmlReader.Create method with a secure XmlReaderSettings argument. Unless you need to enable it, ensure the DtdProcessing property is set to false.
dotnet_diagnostic.CA3077.severity = error
## CA3076 : Insecure XSLT script processing (category : Security / default: none)
## Providing an insecure XsltSettings instance and an insecure XmlResolver instance to XslCompiledTransform.Load method is potentially unsafe as it allows processing script within XSL, which on an untrusted XSL input may lead to malicious code execution. Either replace the insecure XsltSettings argument with XsltSettings.Default or an instance that has disabled document function and script execution, or replace the XmlResolver argument with null or an XmlSecureResolver instance. This message may be suppressed if the input is known to be from a trusted source and external resource resolution from locations that are not known in advance must be supported.
dotnet_diagnostic.CA3076.severity = error
## CA3147 : Mark Verb Handlers With Validate Antiforgery Token (category : Security / default: none)
dotnet_diagnostic.CA3147.severity = error
## CA3147 : Mark Verb Handlers With Validate Antiforgery Token (category : Security / default: none)
dotnet_diagnostic.CA3147.severity = error
## CA3147 : Mark Verb Handlers With Validate Antiforgery Token (category : Security / default: none)
dotnet_diagnostic.CA3147.severity = error
## CA3147 : Mark Verb Handlers With Validate Antiforgery Token (category : Security / default: none)
dotnet_diagnostic.CA3147.severity = error
## CA3147 : Mark Verb Handlers With Validate Antiforgery Token (category : Security / default: none)
dotnet_diagnostic.CA3147.severity = error
## CA1058 : Types should not extend certain base types (category : Design / default: warning)
## An externally visible type extends certain base types. Use one of the alternatives.
dotnet_diagnostic.CA1058.severity = error

#######################################################
## Microsoft.CodeAnalysis.CSharp.NetAnalyzers
#######################################################
## CA1851 : Possible multiple enumerations of 'IEnumerable' collection (category : Performance / default: warning)
dotnet_diagnostic.CA1851.severity = error
## CA1865 : Use char overload (category : Performance / default: suggestion)
## The char overload is a better performing overload than a string with a single char.
dotnet_diagnostic.CA1865.severity = error
## CA1866 : Use char overload (category : Performance / default: suggestion)
## The char overload is a better performing overload than a string with a single char.
dotnet_diagnostic.CA1866.severity = error
## CA1867 : Use char overload (category : Performance / default: warning)
## The char overload is a better performing overload than a string with a single char.
dotnet_diagnostic.CA1867.severity = error
## CA1032 : Implement standard exception constructors (category : Design / default: warning)
## Failure to provide the full set of constructors can make it difficult to correctly handle exceptions.
dotnet_diagnostic.CA1032.severity = none # Redundant with S4027
## CA2234 : Pass system uri objects instead of strings (category : Usage / default: warning)
## A call is made to a method that has a string parameter whose name contains "uri", "URI", "urn", "URN", "url", or "URL". The declaring type of the method contains a corresponding method overload that has a System.Uri parameter.
dotnet_diagnostic.CA2234.severity = error
## CA1200 : Avoid using cref tags with a prefix (category : Documentation / default: none)
## Use of cref tags with prefixes should be avoided, since it prevents the compiler from verifying references and the IDE from updating references during refactorings. It is permissible to suppress this error at a single documentation site if the cref must use a prefix because the type being mentioned is not findable by the compiler. For example, if a cref is mentioning a special attribute in the full framework but you're in a file that compiles against the portable framework, or if you want to reference a type at higher layer of Roslyn, you should suppress the error. You should not suppress the error just because you want to take a shortcut and avoid using the full syntax.
dotnet_diagnostic.CA1200.severity = error
## CA1508 : Avoid dead conditional code (category : Maintainability / default: warning)
dotnet_diagnostic.CA1508.severity = error
## CA1508 : Avoid dead conditional code (category : Maintainability / default: warning)
dotnet_diagnostic.CA1508.severity = error
## CA1507 : Use nameof to express symbol names (category : Maintainability / default: suggestion)
## Using nameof helps keep your code valid when refactoring.
dotnet_diagnostic.CA1507.severity = error
## CA1805 : Do not initialize unnecessarily (category : Performance / default: none)
## The .NET runtime initializes all fields of reference types to their default values before running the constructor. In most cases, explicitly initializing a field to its default value in a constructor is redundant, adding maintenance costs and potentially degrading performance (such as with increased assembly size), and the explicit initialization can be removed.  In some cases, such as with static readonly fields that permanently retain their default value, consider instead changing them to be constants or properties.
dotnet_diagnostic.CA1805.severity = none # Sometime I prefer to initialize fields to their default value, so I can see them in code easily.
## CA1802 : Use literals where appropriate (category : Performance / default: warning)
## A field is declared static and read-only (Shared and ReadOnly in Visual Basic), and is initialized by using a value that is computable at compile time. Because the value that is assigned to the targeted field is computable at compile time, change the declaration to a const (Const in Visual Basic) field so that the value is computed at compile time instead of at runtime.
dotnet_diagnostic.CA1802.severity = error
## CA1802 : Use literals where appropriate (category : Performance / default: warning)
## A field is declared static and read-only (Shared and ReadOnly in Visual Basic), and is initialized by using a value that is computable at compile time. Because the value that is assigned to the targeted field is computable at compile time, change the declaration to a const (Const in Visual Basic) field so that the value is computed at compile time instead of at runtime.
dotnet_diagnostic.CA1802.severity = error
## CA1855 : Prefer 'Clear' over 'Fill' (category : Performance / default: suggestion)
## It is more efficient to use 'Clear', instead of 'Fill' with default value.
dotnet_diagnostic.CA1855.severity = error
## CA1856 : Incorrect usage of ConstantExpected attribute (category : Performance / default: error)
## ConstantExpected attribute is not applied correctly on the parameter.
dotnet_diagnostic.CA1856.severity = error
## CA1856 : Incorrect usage of ConstantExpected attribute (category : Performance / default: error)
## ConstantExpected attribute is not applied correctly on the parameter.
dotnet_diagnostic.CA1856.severity = error
## CA1856 : Incorrect usage of ConstantExpected attribute (category : Performance / default: error)
## ConstantExpected attribute is not applied correctly on the parameter.
dotnet_diagnostic.CA1856.severity = error
## CA1856 : Incorrect usage of ConstantExpected attribute (category : Performance / default: error)
## ConstantExpected attribute is not applied correctly on the parameter.
dotnet_diagnostic.CA1856.severity = error
## CA1857 : A constant is expected for the parameter (category : Performance / default: warning)
## The parameter expects a constant for optimal performance.
dotnet_diagnostic.CA1857.severity = error
## CA1857 : A constant is expected for the parameter (category : Performance / default: warning)
## The parameter expects a constant for optimal performance.
dotnet_diagnostic.CA1857.severity = error
## CA1857 : A constant is expected for the parameter (category : Performance / default: warning)
## The parameter expects a constant for optimal performance.
dotnet_diagnostic.CA1857.severity = error
## CA1857 : A constant is expected for the parameter (category : Performance / default: warning)
## The parameter expects a constant for optimal performance.
dotnet_diagnostic.CA1857.severity = error
## CA1870 : Use a cached 'SearchValues' instance (category : Performance / default: suggestion)
## Using a cached 'SearchValues' instance is more efficient than passing values to 'IndexOfAny'/'ContainsAny' directly.
dotnet_diagnostic.CA1870.severity = error
## CA1824 : Mark assemblies with NeutralResourcesLanguageAttribute (category : Performance / default: suggestion)
## The NeutralResourcesLanguage attribute informs the ResourceManager of the language that was used to display the resources of a neutral culture for an assembly. This improves lookup performance for the first resource that you load and can reduce your working set.
dotnet_diagnostic.CA1824.severity = error
## CA1825 : Avoid zero-length array allocations (category : Performance / default: suggestion)
dotnet_diagnostic.CA1825.severity = error
## CA2252 : This API requires opting into preview features (category : Usage / default: error)
## An assembly has to opt into preview features before using them.
dotnet_diagnostic.CA2252.severity = error
## CA2252 : This API requires opting into preview features (category : Usage / default: error)
## An assembly has to opt into preview features before using them.
dotnet_diagnostic.CA2252.severity = error
## CA2252 : This API requires opting into preview features (category : Usage / default: error)
## An assembly has to opt into preview features before using them.
dotnet_diagnostic.CA2252.severity = error
## CA2252 : This API requires opting into preview features (category : Usage / default: error)
## An assembly has to opt into preview features before using them.
dotnet_diagnostic.CA2252.severity = error
## CA2252 : This API requires opting into preview features (category : Usage / default: error)
## An assembly has to opt into preview features before using them.
dotnet_diagnostic.CA2252.severity = error
## CA2252 : This API requires opting into preview features (category : Usage / default: error)
## An assembly has to opt into preview features before using them.
dotnet_diagnostic.CA2252.severity = error
## CA2252 : This API requires opting into preview features (category : Usage / default: error)
## An assembly has to opt into preview features before using them.
dotnet_diagnostic.CA2252.severity = error
## CA2252 : This API requires opting into preview features (category : Usage / default: error)
## An assembly has to opt into preview features before using them.
dotnet_diagnostic.CA2252.severity = error
## CA2252 : This API requires opting into preview features (category : Usage / default: error)
## An assembly has to opt into preview features before using them.
dotnet_diagnostic.CA2252.severity = error
## CA2252 : This API requires opting into preview features (category : Usage / default: error)
## An assembly has to opt into preview features before using them.
dotnet_diagnostic.CA2252.severity = error
## CA2252 : This API requires opting into preview features (category : Usage / default: error)
## An assembly has to opt into preview features before using them.
dotnet_diagnostic.CA2252.severity = error
## CA2252 : This API requires opting into preview features (category : Usage / default: error)
## An assembly has to opt into preview features before using them.
dotnet_diagnostic.CA2252.severity = error
## CA2252 : This API requires opting into preview features (category : Usage / default: error)
## An assembly has to opt into preview features before using them.
dotnet_diagnostic.CA2252.severity = error
## CA2252 : This API requires opting into preview features (category : Usage / default: error)
## An assembly has to opt into preview features before using them.
dotnet_diagnostic.CA2252.severity = error
## CA2252 : This API requires opting into preview features (category : Usage / default: error)
## An assembly has to opt into preview features before using them.
dotnet_diagnostic.CA2252.severity = error
## CA2252 : This API requires opting into preview features (category : Usage / default: error)
## An assembly has to opt into preview features before using them.
dotnet_diagnostic.CA2252.severity = error
## CA2252 : This API requires opting into preview features (category : Usage / default: error)
## An assembly has to opt into preview features before using them.
dotnet_diagnostic.CA2252.severity = error
## CA2252 : This API requires opting into preview features (category : Usage / default: error)
## An assembly has to opt into preview features before using them.
dotnet_diagnostic.CA2252.severity = error
## CA2252 : This API requires opting into preview features (category : Usage / default: error)
## An assembly has to opt into preview features before using them.
dotnet_diagnostic.CA2252.severity = error
## CA2014 : Do not use stackalloc in loops (category : Reliability / default: warning)
## Stack space allocated by a stackalloc is only released at the end of the current method's invocation.  Using it in a loop can result in unbounded stack growth and eventual stack overflow conditions.
dotnet_diagnostic.CA2014.severity = error
## CA2016 : Forward the 'CancellationToken' parameter to methods (category : Reliability / default: suggestion)
## Forward the 'CancellationToken' parameter to methods to ensure the operation cancellation notifications gets properly propagated, or pass in 'CancellationToken.None' explicitly to indicate intentionally not propagating the token.
dotnet_diagnostic.CA2016.severity = error
## CA1841 : Prefer Dictionary.Contains methods (category : Performance / default: suggestion)
## 'ContainsKey' is usually O(1), while 'Keys.Contains' may be O(n) in some cases. Additionally, many dictionary implementations lazily initialize the Keys collection to cut back on allocations.
dotnet_diagnostic.CA1841.severity = error
## CA1841 : Prefer Dictionary.Contains methods (category : Performance / default: suggestion)
## Many dictionary implementations lazily initialize the Values collection. To avoid unnecessary allocations, prefer 'ContainsValue' over 'Values.Contains'.
dotnet_diagnostic.CA1841.severity = error
## CA2020 : Prevent behavioral change (category : Reliability / default: suggestion)
## Some built-in operators added in .NET 7 behave differently when overflowing than did the corresponding user-defined operators in .NET 6 and earlier versions. Some operators that previously threw in an unchecked context now don't throw unless wrapped within a checked context. Also, some operators that did not previously throw in a checked context now throw unless wrapped in an unchecked context.
dotnet_diagnostic.CA2020.severity = error
## CA2020 : Prevent behavioral change (category : Reliability / default: suggestion)
## Some built-in operators added in .NET 7 behave differently when overflowing than did the corresponding user-defined operators in .NET 6 and earlier versions. Some operators that previously threw in an unchecked context now don't throw unless wrapped within a checked context. Also, some operators that did not previously throw in a checked context now throw unless wrapped in an unchecked context.
dotnet_diagnostic.CA2020.severity = error
## CA2020 : Prevent behavioral change (category : Reliability / default: suggestion)
## Some built-in operators added in .NET 7 behave differently when overflowing than did the corresponding user-defined operators in .NET 6 and earlier versions. Some operators that previously threw in an unchecked context now don't throw unless wrapped within a checked context. Also, some operators that did not previously throw in a checked context now throw unless wrapped in an unchecked context.
dotnet_diagnostic.CA2020.severity = error
## CA1311 : Specify a culture or use an invariant version (category : Globalization / default: none)
## Specify culture to help avoid accidental implicit dependency on current culture. Using an invariant version yields consistent results regardless of the culture of an application.
dotnet_diagnostic.CA1311.severity = error
## CA1309 : Use ordinal string comparison (category : Globalization / default: none)
## A string comparison operation that is nonlinguistic does not set the StringComparison parameter to either Ordinal or OrdinalIgnoreCase. By explicitly setting the parameter to either StringComparison.Ordinal or StringComparison.OrdinalIgnoreCase, your code often gains speed, becomes more correct, and becomes more reliable.
dotnet_diagnostic.CA1309.severity = error
## CA1845 : Use span-based 'string.Concat' (category : Performance / default: suggestion)
## It is more efficient to use 'AsSpan' and 'string.Concat', instead of 'Substring' and a concatenation operator.
dotnet_diagnostic.CA1845.severity = error
## CA2354 : Unsafe DataSet or DataTable in deserialized object graph can be vulnerable to remote code execution attacks (category : Security / default: warning)
dotnet_diagnostic.CA2354.severity = error
## CA2355 : Unsafe DataSet or DataTable type found in deserializable object graph (category : Security / default: warning)
dotnet_diagnostic.CA2355.severity = error
## CA2352 : Unsafe DataSet or DataTable in serializable type can be vulnerable to remote code execution attacks (category : Security / default: warning)
dotnet_diagnostic.CA2352.severity = error
## CA2353 : Unsafe DataSet or DataTable in serializable type (category : Security / default: warning)
dotnet_diagnostic.CA2353.severity = error
## CA2362 : Unsafe DataSet or DataTable in auto-generated serializable type can be vulnerable to remote code execution attacks (category : Security / default: warning)
dotnet_diagnostic.CA2362.severity = error
## CA2356 : Unsafe DataSet or DataTable type in web deserializable object graph (category : Security / default: warning)
dotnet_diagnostic.CA2356.severity = error
## CA2260 : Use correct type parameter (category : Usage / default: warning)
## Generic math interfaces require the derived type itself to be used for the self recurring type parameter.
dotnet_diagnostic.CA2260.severity = error

#######################################################
## SonarAnalyzer.CSharp
#######################################################
## S1694 : An abstract class should have both abstract and concrete methods (category : Minor Code Smell / default: warning)
## A class with only abstract methods and no inheritable behavior should be converted to an interface.
dotnet_diagnostic.S1694.severity = error
## S3442 : "abstract" classes should not have "public" constructors (category : Major Code Smell / default: warning)
## The abstract modifier in a class declaration is used to indicate that a class is intended only to be a base class of other classes, not instantiated on its own.
dotnet_diagnostic.S3442.severity = error
## S3923 : All branches in a conditional structure should not have exactly the same implementation (category : Major Bug / default: warning)
## Having all branches of a switch or if chain with the same implementation indicates a problem.
dotnet_diagnostic.S3923.severity = error
## S6562 : Always set the "DateTimeKind" when creating new "DateTime" instances (category : Major Code Smell / default: warning)
## Not knowing the Kind of the DateTime object that an application is using can lead to misunderstandings when displaying or comparing them. Explicitly setting the Kind property helps the application to stay consistent, and its maintainers understand what kind of date is being managed. To achieve this, when instantiating a new DateTime object you should always use a constructor overload that allows you to define the Kind property.
dotnet_diagnostic.S6562.severity = error
## S9999-warning : Analysis Warning generator (category :  / default: warning)
dotnet_diagnostic.S9999-warning.severity = error
## S6965 : REST API actions should be annotated with an HTTP verb attribute (category : Major Code Smell / default: warning)
## When building a REST API, it’s recommended to annotate the controller actions with the available HTTP attributes to be precise about what your API supports.
dotnet_diagnostic.S6965.severity = error
## S3244 : Anonymous delegates should not be used to unsubscribe from Events (category : Major Bug / default: warning)
## When working with anonymous functions, it is important to keep in mind that each time you create one, it is a completely new instance.
dotnet_diagnostic.S3244.severity = error
## S6961 : API Controllers should derive from ControllerBase instead of Controller (category : Major Code Smell / default: warning)
## In ASP.NET Core, controllers usually inherit either from ControllerBase or Controller. If a controller does not use any View-specific functionality, it is recommended to inherit from ControllerBase.
dotnet_diagnostic.S6961.severity = error
## S3236 : Caller information arguments should not be provided explicitly (category : Minor Code Smell / default: warning)
## Caller information attributes: CallerFilePathAttribute, CallerLineNumberAttribute, and CallerArgumentExpressionAttribute provide a way to get information about the caller of a method through optional parameters. But the arguments for these optional parameters are only generated if they are not explicitly defined in the call. Thus, specifying the argument values defeats the purpose of the attributes.
dotnet_diagnostic.S3236.severity = error
## S2330 : Array covariance should not be used (category : Critical Code Smell / default: warning)
## Array covariance is the principle that if an implicit or explicit reference conversion exits from type A to B, then the same conversion exists from the array type A[] to B[].
dotnet_diagnostic.S2330.severity = error
## S3878 : Arrays should not be created for params parameters (category : Minor Code Smell / default: warning)
## There’s no point in creating an array solely for the purpose of passing it to a params parameter. Simply pass the elements directly. They will be consolidated into an array automatically.
dotnet_diagnostic.S3878.severity = error
## S3415 : Assertion arguments should be passed in the correct order (category : Major Code Smell / default: warning)
## The standard assertions library methods such as AreEqual and AreSame in MSTest and NUnit, or Equal and Same in XUnit, expect the first argument to be the expected value and the second argument to be the actual value.
dotnet_diagnostic.S3415.severity = error
## S2970 : Assertions should be complete (category : Blocker Code Smell / default: warning)
## This rule addresses the issue of incomplete assertions that can occur when using certain test frameworks. Incomplete assertions can lead to tests that do not effectively verify anything. The rule enforces the use of complete assertions in specific cases, namely:
dotnet_diagnostic.S2970.severity = error
## S1121 : Assignments should not be made from within sub-expressions (category : Major Code Smell / default: warning)
## A common code smell that can hinder the clarity of source code is making assignments within sub-expressions. This practice involves assigning a value to a variable inside a larger expression, such as within a loop or a conditional statement.
dotnet_diagnostic.S1121.severity = error
## S2306 : "async" and "await" should not be used as identifiers (category : Blocker Code Smell / default: warning)
## Since C# 5.0, async and await are contextual keywords. Contextual keywords do have a particular meaning in some contexts, but are not reserved and therefore can be used as variable names.
dotnet_diagnostic.S2306.severity = error
## S3168 : "async" methods should not return "void" (category : Major Bug / default: warning)
## An async method with a void return type does not follow the task asynchronous programming (TAP) model since the return type should be Task or Task{TResult}
dotnet_diagnostic.S3168.severity = error
## S6561 : Avoid using "DateTime.Now" for benchmarking or timing operations (category : Major Code Smell / default: warning)
## The rule targets the use of DateTime.Now call followed by some arithmetic operation.
dotnet_diagnostic.S6561.severity = error
## S1200 : Classes should not be coupled to too many other classes (category : Major Code Smell / default: warning)
## According to the Single Responsibility Principle, introduced by Robert C. Martin in his book "Principles of Object Oriented Design", a class should have only one responsibility:
dotnet_diagnostic.S1200.severity = error
## S110 : Inheritance tree of classes should not be too deep (category : Major Code Smell / default: warning)
## Inheritance is one of the most valuable concepts in object-oriented programming. It’s a way to categorize and reuse code by creating collections of attributes and behaviors called classes, which can be based on previously created classes.
dotnet_diagnostic.S110.severity = error
## S6802 : Using lambda expressions in loops should be avoided in Blazor markup section (category : Major Code Smell / default: warning)
## In Blazor, using lambda expressions as event handlers when the UI elements are rendered in a loop can lead to negative user experiences and performance issues. This is particularly noticeable when rendering a large number of elements.
dotnet_diagnostic.S6802.severity = error
## S6964 : Value type property used as input in a controller action should be nullable, required or annotated with the JsonRequiredAttribute to avoid under-posting. (category : Major Code Smell / default: warning)
## "Under-posting" refers to a situation where a client sends less data than expected to the server during an HTTP request, for example when the client omits some properties from the request body that the server expects to receive.
dotnet_diagnostic.S6964.severity = error
## S4060 : Non-abstract attributes should be sealed (category : Minor Code Smell / default: warning)
## The .NET framework class library provides methods for retrieving custom attributes. Sealing the attribute eliminates the search through the inheritance hierarchy, and can improve performance.
dotnet_diagnostic.S4060.severity = error
## S6421 : Azure Functions should use Structured Error Handling (category : Major Code Smell / default: warning)
## The top-most level of an Azure Function code should include a try/catch block to capture and log all errors so you can monitor the health of the application effectively. In case a retry policy has been defined for your Azure Function, you should rethrow any errors that should result in a retry.
dotnet_diagnostic.S6421.severity = error
## S6423 : Azure Functions should log all failures (category : Major Code Smell / default: warning)
## Capturing and logging errors is critical to monitoring the health of your Azure Functions application.
dotnet_diagnostic.S6423.severity = error
## S6420 : Client instances should not be recreated on each Azure Function invocation (category : Major Code Smell / default: warning)
## To avoid holding more connections than necessary and to avoid potentially exhausting the number of available sockets when using HttpClient, DocumentClient, QueueClient, ConnectionMultiplexer or Azure Storage clients, consider:
dotnet_diagnostic.S6420.severity = error
## S6419 : Azure Functions should be stateless (category : Major Code Smell / default: warning)
## An Azure Function should be stateless as there’s no control over where and when function instances are provisioned and de-provisioned. Managing and storing data/state between requests can lead to inconsistencies. If, for any reason, you need to have a stateful function, consider using the Durable Functions extension of Azure Functions.
dotnet_diagnostic.S6419.severity = error
## S6930 : Backslash should be avoided in route templates (category : Major Bug / default: warning)
## Backslash characters (\) should be avoided in route templates.
dotnet_diagnostic.S6930.severity = error
## S4583 : Calls to delegate's method "BeginInvoke" should be paired with calls to "EndInvoke" (category : Critical Bug / default: warning)
## When calling the BeginInvoke method of a delegate, resources are allocated that are only freed up when EndInvoke is called. Failing to pair BeginInvoke with EndInvoke can lead to resource leaks and incomplete asynchronous calls.
dotnet_diagnostic.S4583.severity = error
## S1764 : Identical expressions should not be used on both sides of operators (category : Major Bug / default: warning)
## Using the same value on both sides of certain operators is a code defect. In the case of logical operators, it is either a copy/paste error and, therefore, a bug, or it is simply duplicated code and should be simplified. For bitwise operators and most binary mathematical operators, having the same value on both sides of an operator yields predictable results and should be simplified as well to avoid further code defects.
dotnet_diagnostic.S1764.severity = error
## S6803 : Parameters with SupplyParameterFromQuery attribute should be used only in routable components (category : Major Code Smell / default: warning)
## This rule is deprecated, and will eventually be removed.
dotnet_diagnostic.S6803.severity = error
## S6797 : Blazor query parameter type should be supported (category : Major Bug / default: warning)
## The SupplyParameterFromQuery attribute can be used to specify that a component parameter, of a routable component, comes from the query string.
dotnet_diagnostic.S6797.severity = error
## S1940 : Boolean checks should not be inverted (category : Minor Code Smell / default: warning)
## It is needlessly complex to invert the result of a boolean comparison. The opposite comparison should be made instead.
dotnet_diagnostic.S1940.severity = error
## S1125 : Boolean literals should not be redundant (category : Minor Code Smell / default: warning)
## A boolean literal can be represented in two different ways: true or false. They can be combined with logical operators (!, And, ||, ==, !=) to produce logical expressions that represent truth values. However, comparing a boolean literal to a variable or expression that evaluates to a boolean value is unnecessary and can make the code harder to read and understand. The more complex a boolean expression is, the harder it will be for developers to understand its meaning and expected behavior, and it will favour the introduction of new bugs.
dotnet_diagnostic.S1125.severity = error
## S1227 : break statements should not be used except for switch cases (category : Minor Code Smell / default: warning)
## break; is an unstructured control flow statement which makes code harder to read.
dotnet_diagnostic.S1227.severity = error
## S3011 : Reflection should not be used to increase accessibility of classes, methods, or fields (category : Major Code Smell / default: warning)
## Altering or bypassing the accessibility of classes, methods, or fields through reflection violates the encapsulation principle. This can break the internal contracts of the accessed target and lead to maintainability issues and runtime errors.
dotnet_diagnostic.S3011.severity = error
## S3343 : Caller information parameters should come at the end of the parameter list (category : Major Bug / default: warning)
## Caller information attributes provide a way to get information about the caller of a method through optional parameters. But they only work right if their values aren’t provided explicitly. So if you define a method with caller info attributes in the middle of the parameter list, the caller is forced to use named arguments if they want to use the method properly.
dotnet_diagnostic.S3343.severity = error
## S6967 : ModelState.IsValid should be called in controller actions (category : Major Code Smell / default: warning)
## In the context of ASP.NET Core MVC web applications, both model binding and model validation are processes that take place prior to the execution of a controller action. It is imperative for the application to examine the ModelState.IsValid and respond accordingly.
dotnet_diagnostic.S6967.severity = error
## S4462 : Calls to "async" methods should not be blocking (category : Blocker Code Smell / default: warning)
## Making blocking calls to async methods transforms code that was intended to be asynchronous into a blocking operation. Doing so can cause deadlocks and unexpected blocking of context threads.
dotnet_diagnostic.S4462.severity = error
## S6422 : Calls to "async" methods should not be blocking in Azure Functions (category : Blocker Code Smell / default: warning)
## Making blocking calls to async methods transforms the code into a synchronous operation. Doing so inside an Azure Function can lead to thread pool exhaustion.
dotnet_diagnostic.S6422.severity = error
## S3215 : "interface" instances should not be cast to concrete types (category : Critical Code Smell / default: warning)
## Needing to cast from an interface to a concrete type indicates that something is wrong with the abstractions in use, likely that something is missing from the interface. Instead of casting to a discrete type, the missing functionality should be added to the interface. Otherwise there is a risk of runtime exceptions.
dotnet_diagnostic.S3215.severity = error
## S3247 : Duplicate casts should not be made (category : Minor Code Smell / default: warning)
## In C#, the is type testing operator can be used to check if the run-time type of an object is compatible with a given type. If the object is not null, then the is operator performs a cast, and so performing another cast following the check result is redundant.
dotnet_diagnostic.S3247.severity = error
## S2486 : Generic exceptions should not be ignored (category : Minor Code Smell / default: warning)
## When exceptions occur, it is usually a bad idea to simply ignore them. Instead, it is better to handle them properly, or at least to log them.
dotnet_diagnostic.S2486.severity = error
## S2737 : "catch" clauses should do more than rethrow (category : Minor Code Smell / default: warning)
## A catch clause that only rethrows the caught exception has the same effect as omitting the catch altogether and letting it bubble up automatically.
dotnet_diagnostic.S2737.severity = error
## S4830 : Server certificates should be verified during SSL/TLS connections (category : Critical Vulnerability / default: warning)
## This vulnerability makes it possible that an encrypted communication is intercepted.
dotnet_diagnostic.S4830.severity = error
## S3928 : Parameter names used into ArgumentException constructors should match an existing one  (category : Major Code Smell / default: warning)
## Some constructors of the ArgumentException, ArgumentNullException, ArgumentOutOfRangeException and DuplicateWaitObjectException classes must be fed with a valid parameter name. This rule raises an issue in two cases:
dotnet_diagnostic.S3928.severity = error
## S100 : Methods and properties should be named in PascalCase (category : Minor Code Smell / default: warning)
## Shared naming conventions allow teams to collaborate efficiently.
dotnet_diagnostic.S100.severity = error
## S101 : Types should be named in PascalCase (category : Minor Code Smell / default: warning)
## Shared naming conventions allow teams to collaborate efficiently.
dotnet_diagnostic.S101.severity = error
## S2166 : Classes named like "Exception" should extend "Exception" or a subclass (category : Major Code Smell / default: warning)
## Clear, communicative naming is important in code. It helps maintainers and API users understand the intentions for and uses of a unit of code. Using "exception" in the name of a class that does not extend Exception or one of its subclasses is a clear violation of the expectation that a class' name will indicate what it is and/or does.
dotnet_diagnostic.S2166.severity = error
## S3453 : Classes should not have only "private" constructors (category : Major Bug / default: warning)
## When a class has only a private constructor, it can’t be instantiated except within the class itself. Such classes can be considered dead code and should be fixed
dotnet_diagnostic.S3453.severity = error
## S2094 : Classes should not be empty (category : Minor Code Smell / default: warning)
## There is no good excuse for an empty class. If it’s being used simply as a common extension point, it should be replaced with an interface. If it was stubbed in as a placeholder for future development it should be fleshed-out. In any other case, it should be eliminated.
dotnet_diagnostic.S2094.severity = error
## S3897 : Classes that provide "Equals({T})" should implement "IEquatable{T}" (category : Minor Code Smell / default: warning)
## The IEquatable{T} interface has only one method in it: Equals({T}). If you’ve already written Equals(T), there’s no reason not to explicitly implement IEquatable{T}. Doing so expands the utility of your class by allowing it to be used where an IEquatable is called for.
dotnet_diagnostic.S3897.severity = error
## S1118 : Utility classes should not have public constructors (category : Major Code Smell / default: warning)
## Whenever there are portions of code that are duplicated and do not depend on the state of their container class, they can be centralized inside a "utility class". A utility class is a class that only has static members, hence it should not be instantiated.
dotnet_diagnostic.S1118.severity = error
## S5332 : Using clear-text protocols is security-sensitive (category : Critical Security Hotspot / default: warning)
## Clear-text protocols such as ftp, telnet, or http lack encryption of transported data, as well as the capability to build an authenticated connection. It means that an attacker able to sniff traffic from the network can read, modify, or corrupt the transported content. These protocols are not secure as they expose applications to an extensive range of risks:
dotnet_diagnostic.S5332.severity = error
## S5332 : Using clear-text protocols is security-sensitive (category : Critical Security Hotspot / default: warning)
## Clear-text protocols such as ftp, telnet, or http lack encryption of transported data, as well as the capability to build an authenticated connection. It means that an attacker able to sniff traffic from the network can read, modify, or corrupt the transported content. These protocols are not secure as they expose applications to an extensive range of risks:
dotnet_diagnostic.S5332.severity = error
## S3776 : Cognitive Complexity of methods should not be too high (category : Critical Code Smell / default: warning)
## This rule raises an issue when the code cognitive complexity of a function is above a certain threshold.
dotnet_diagnostic.S3776.severity = error
## S1155 : "Any()" should be used to test for emptiness (category : Minor Code Smell / default: warning)
## When you call Any(), it clearly communicates the code’s intention, which is to check if the collection is empty. Using Count() == 0 for this purpose is less direct and makes the code slightly more complex. However, there are some cases where special attention should be paid:
dotnet_diagnostic.S1155.severity = error
## S4004 : Collection properties should be readonly (category : Major Code Smell / default: warning)
## A writable collection property can be replaced by a completely different collection. Making it readonly prevents that while still allowing individual members to be set. If you want to allow the replacement of the whole collection the recommended pattern is to implement a method to remove all the elements (e.g. System.Collections.List{T}.Clear) and a method to populate the collection (e.g. System.Collections.List{T}.AddRange).
dotnet_diagnostic.S4004.severity = error
## S2971 : LINQ expressions should be simplified (category : Major Code Smell / default: warning)
## In the interests of readability, code that can be simplified should be simplified. To that end, there are several ways IEnumerable language integrated queries (LINQ) can be simplified. This not only improves readabilty but can also lead to improved performance.
dotnet_diagnostic.S2971.severity = error
## S3909 : Collections should implement the generic interface (category : Major Code Smell / default: warning)
## The NET Framework 2.0 introduced the generic interface System.Collections.Generic.IEnumerable{T} and it should be preferred over the older, non generic, interfaces.
dotnet_diagnostic.S3909.severity = error
## S4036 : Searching OS commands in PATH is security-sensitive (category : Minor Security Hotspot / default: warning)
## When executing an OS command and unless you specify the full path to the executable, then the locations in your application’s PATH environment variable will be searched for the executable. That search could leave an opening for an attacker if one of the elements in PATH is a directory under his control.
dotnet_diagnostic.S4036.severity = error
## S125 : Sections of code should not be commented out (category : Major Code Smell / default: warning)
## Commented-out code distracts the focus from the actual executed code. It creates a noise that increases maintenance code. And because it is never executed, it quickly becomes out of date and invalid.
dotnet_diagnostic.S125.severity = error
## S1134 : Track uses of "FIXME" tags (category : Major Code Smell / default: warning)
## FIXME tags are commonly used to mark places where a bug is suspected, but which the developer wants to deal with later.
dotnet_diagnostic.S1134.severity = error
## S4663 : Comments should not be empty (category : Minor Code Smell / default: warning)
## Empty comments, as shown in the example, hurt readability and might indicate an oversight.
dotnet_diagnostic.S4663.severity = error
## S1210 : "Equals" and the comparison operators should be overridden when implementing "IComparable" (category : Minor Code Smell / default: warning)
## When you implement IComparable or IComparable{T} on a class you should also override Equals(object) and overload the comparison operators (==, !=, <, <=, >, >=). That’s because the CLR cannot automatically call your CompareTo implementation from Equals(object) or from the base comparison operator implementations. Additionally, it is best practice to override GetHashCode along with Equals.
dotnet_diagnostic.S1210.severity = error
## S2688 : "NaN" should not be used in comparisons (category : Major Bug / default: warning)
## double.NaN and float.NaN are not equal to anything, not even themselves.
dotnet_diagnostic.S2688.severity = error
## S3240 : The simplest possible condition syntax should be used (category : Minor Code Smell / default: warning)
## In the interests of keeping code clean, the simplest possible conditional syntax should be used. That means
dotnet_diagnostic.S3240.severity = error
## S3240 : The simplest possible condition syntax should be used (category : Minor Code Smell / default: warning)
## In the interests of keeping code clean, the simplest possible conditional syntax should be used. That means
dotnet_diagnostic.S3240.severity = error
## S3972 : Conditionals should start on new lines (category : Critical Code Smell / default: warning)
## Placing an if statement on the same line as the closing } from a preceding if, else, or else if block can lead to confusion and potential errors. It may indicate a missing else statement or create ambiguity for maintainers who might fail to understand that the two statements are unconnected.
dotnet_diagnostic.S3972.severity = error
## S1862 : Related "if/else if" statements should not have the same condition (category : Major Bug / default: warning)
## A chain of if/else if statements is evaluated from top to bottom. At most, only one branch will be executed: the first statement with a condition that evaluates to true. Therefore, duplicating a condition leads to unreachable code inside the duplicated condition block. Usually, this is due to a copy/paste error.
dotnet_diagnostic.S1862.severity = error
## S1871 : Two branches in a conditional structure should not have exactly the same implementation (category : Major Code Smell / default: warning)
## When the same code is duplicated in two or more separate branches of a conditional, it can make the code harder to understand, maintain, and can potentially introduce bugs if one instance of the code is changed but others are not.
dotnet_diagnostic.S1871.severity = error
## S2760 : Sequential tests should not check the same condition (category : Minor Code Smell / default: warning)
## When the same condition is checked twice in a row, it is either confusing - why have separate checks? - or an error - some other condition should have been checked in the second test.
dotnet_diagnostic.S2760.severity = error
## S4792 : Configuring loggers is security-sensitive (category : Critical Security Hotspot / default: warning)
## This rule is deprecated, and will eventually be removed.
dotnet_diagnostic.S4792.severity = error
## S4260 : "ConstructorArgument" parameters should exist in constructors (category : Major Bug / default: warning)
## When creating a custom Markup Extension that accepts parameters in WPF, the ConstructorArgument markup must be used to identify the discrete properties that match these parameters. However since this is done via a string, the compiler won’t give you any warning in case there are typos.
dotnet_diagnostic.S4260.severity = error
## S1699 : Constructors should only call non-overridable methods (category : Critical Code Smell / default: warning)
## Calling an overridable method from a constructor could result in failures or strange behaviors when instantiating a subclass which overrides the method.
dotnet_diagnostic.S1699.severity = error
## S5034 : "ValueTask" should be consumed correctly (category : Critical Code Smell / default: warning)
## ValueTask{TResult} provides a value type that wraps a Task{TResult} and the corresponding TResult. It was introduced in .NET Core 2.0 to optimize memory allocation when functions return their results synchronously.
dotnet_diagnostic.S5034.severity = error
## S2479 : Whitespace and control characters in string literals should be explicit (category : Critical Code Smell / default: warning)
## Non-encoded control characters and whitespace characters are often injected in the source code because of a bad manipulation. They are either invisible or difficult to recognize, which can result in bugs when the string is not what the developer expects. If you actually need to use a control character use their encoded version:
dotnet_diagnostic.S2479.severity = error
## S6960 : Controllers should not have mixed responsibilities (category : Major Code Smell / default: warning)
## ASP.NET controllers should not have mixed responsibilities. Following the Single Responsibility Principle (SRP), they should be kept lean and focused on a single, separate concern. In short, they should have a single reason to change.
dotnet_diagnostic.S6960.severity = error
## S6962 : You should pool HTTP connections with HttpClientFactory (category : Major Code Smell / default: warning)
## In frequently used code paths, such as controller actions, you should avoid using the HttpClient directly and opt for one of the IHttpClientFactory-based mechanisms instead. This way, you avoid wasting resources and creating performance overhead.
dotnet_diagnostic.S6962.severity = error
## S3330 : Creating cookies without the "HttpOnly" flag is security-sensitive (category : Minor Security Hotspot / default: warning)
## When a cookie is configured with the HttpOnly attribute set to true, the browser guaranties that no client-side script will be able to read it. In most cases, when a cookie is created, the default value of HttpOnly is false and it’s up to the developer to decide whether or not the content of the cookie can be read by the client-side script. As a majority of Cross-Site Scripting (XSS) attacks target the theft of session-cookies, the HttpOnly attribute can help to reduce their impact as it won’t be possible to exploit the XSS vulnerability to steal session-cookies.
dotnet_diagnostic.S3330.severity = error
## S2092 : Creating cookies without the "secure" flag is security-sensitive (category : Minor Security Hotspot / default: warning)
## When a cookie is protected with the secure attribute set to true it will not be send by the browser over an unencrypted HTTP request and thus cannot be observed by an unauthorized person during a man-in-the-middle attack.
dotnet_diagnostic.S2092.severity = error
## S9999-cpd : Copy-paste token calculator (category :  / default: warning)
dotnet_diagnostic.S9999-cpd.severity = error
## S4790 : Using weak hashing algorithms is security-sensitive (category : Critical Security Hotspot / default: warning)
## Cryptographic hash algorithms such as MD2, MD4, MD5, MD6, HAVAL-128, HMAC-MD5, DSA (which uses SHA-1), RIPEMD, RIPEMD-128, RIPEMD-160, HMACRIPEMD160 and SHA-1 are no longer considered secure, because it is possible to have collisions (little computational effort is enough to find two or more different inputs that produce the same hash).
dotnet_diagnostic.S4790.severity = error
## S4426 : Cryptographic keys should be robust (category : Critical Vulnerability / default: warning)
## This vulnerability exposes encrypted data to attacks whose goal is to recover the plaintext.
dotnet_diagnostic.S4426.severity = error
## S3869 : "SafeHandle.DangerousGetHandle" should not be called (category : Blocker Bug / default: warning)
## The SafeHandle.DangerousGetHandle method poses significant risks and should be used carefully. This method carries the inherent danger of potentially returning an invalid handle, which can result in resource leaks and security vulnerabilities. Although it is technically possible to utilize this method without encountering issues, doing so correctly requires a high level of expertise. Therefore, it is recommended to avoid using this method altogether.
dotnet_diagnostic.S3869.severity = error
## S2115 : A secure password should be used when connecting to a database (category : Blocker Vulnerability / default: warning)
## When accessing a database, an empty password should be avoided as it introduces a weakness.
dotnet_diagnostic.S2115.severity = error
## S3363 : Date and time should not be used as a type for primary keys (category : Minor Bug / default: warning)
## You should only set a property of a temporal type (like DateTime or DateTimeOffset) as the primary key of a table if the values are guaranteed to be unique.
dotnet_diagnostic.S3363.severity = error
## S6585 : Don't hardcode the format when turning dates and times to strings (category : Minor Code Smell / default: warning)
## Hardcoding the date and time format strings can lead to formats that consumers misunderstand. Also, if the same format is meant to be used in multiple places, it is easier to make a mistake when it’s hardcoded instead of using a format provided by an IFormatProvider or using one of the standard format strings.
dotnet_diagnostic.S6585.severity = error
## S1854 : Unused assignments should be removed (category : Major Code Smell / default: warning)
## Dead stores refer to assignments made to local variables that are subsequently never used or immediately overwritten. Such assignments are unnecessary and don’t contribute to the functionality or clarity of the code. They may even negatively impact performance. Removing them enhances code cleanliness and readability. Even if the unnecessary operations do not do any harm in terms of the program’s correctness, they are - at best - a waste of computing resources.
dotnet_diagnostic.S1854.severity = error
## S3346 : Expressions used in "Debug.Assert" should not produce side effects (category : Major Bug / default: warning)
## An assertion is a piece of code that’s used during development when the compilation debug mode is activated. It allows a program to check itself as it runs. When an assertion is true, that means everything is operating as expected.
dotnet_diagnostic.S3346.severity = error
## S4545 : "DebuggerDisplayAttribute" strings should reference existing members (category : Major Code Smell / default: warning)
## The DebuggerDisplayAttribute is used to determine how an object is displayed in the debugger window.
dotnet_diagnostic.S4545.severity = error
## S3906 : Event Handlers should have the correct signature (category : Major Code Smell / default: warning)
## Delegate event handlers (i.e. delegates used as type of an event) should have a very specific signature:
dotnet_diagnostic.S3906.severity = error
## S3903 : Types should be defined in named namespaces (category : Major Bug / default: warning)
## Types are declared in namespaces in order to prevent name collisions and as a way to organize them into the object hierarchy. Types that are defined outside any named namespace are in a global namespace that cannot be referenced in code.
dotnet_diagnostic.S3903.severity = error
## S4524 : "default" clauses should be first or last (category : Critical Code Smell / default: warning)
## The switch statement is a conditional statement that executes a sequence of instructions based on patterns matching the provided value.
dotnet_diagnostic.S4524.severity = error
## S3172 : Delegates should not be subtracted (category : Major Bug / default: warning)
## In C#, delegates can be added together to chain their execution, and subtracted to remove their execution from the chain.
dotnet_diagnostic.S3172.severity = error
## S4507 : Delivering code in production with debug features activated is security-sensitive (category : Minor Security Hotspot / default: warning)
## Development tools and frameworks usually have options to make debugging easier for developers. Although these features are useful during development, they should never be enabled for applications deployed in production. Debug instructions or error messages can leak detailed information about the system, like the application’s path or file names.
dotnet_diagnostic.S4507.severity = error
## S4502 : Disabling CSRF protections is security-sensitive (category : Critical Security Hotspot / default: warning)
## A cross-site request forgery (CSRF) attack occurs when a trusted user of a web application can be forced, by an attacker, to perform sensitive actions that he didn’t intend, such as updating his profile or sending a message, more generally anything that can change the state of the application.
dotnet_diagnostic.S4502.severity = error
## S5753 : Disabling ASP.NET "Request Validation" feature is security-sensitive (category : Major Security Hotspot / default: warning)
## ASP.NET 1.1+ comes with a feature called Request Validation, preventing the server to accept content containing un-encoded HTML. This feature comes as a first protection layer against Cross-Site Scripting (XSS) attacks and act as a simple Web Application Firewall (WAF) rejecting requests potentially containing malicious content.
dotnet_diagnostic.S5753.severity = error
## S2931 : Classes with "IDisposable" members should implement "IDisposable" (category : Blocker Bug / default: warning)
## An IDisposable object should be disposed (there are some rare exceptions where not disposing is fine, most notably Task). If a class has an IDisposable field, there can be two situations:
dotnet_diagnostic.S2931.severity = error
## S2930 : "IDisposables" should be disposed (category : Blocker Bug / default: warning)
## When writing managed code, there is no need to worry about memory allocation or deallocation as it is taken care of by the garbage collector. However, certain objects, such as Bitmap, utilize unmanaged memory for specific purposes like pointer arithmetic. These objects may have substantial unmanaged memory footprints while having minimal managed footprints. Unfortunately, the garbage collector only recognizes the small managed footprint and does not promptly reclaim the corresponding unmanaged memory (by invoking the finalizer method of Bitmap) for efficiency reasons.
dotnet_diagnostic.S2930.severity = error
## S2997 : "IDisposables" created in a "using" statement should not be returned (category : Major Bug / default: warning)
## When you use a using statement, the goal is to ensure the correct disposal of an IDisposable instance when the control leaves the using statement block.
dotnet_diagnostic.S2997.severity = error
## S4002 : Disposable types should declare finalizers (category : Major Code Smell / default: warning)
## This rule raises an issue when a disposable type contains fields of the following types and does not implement a finalizer:
dotnet_diagnostic.S4002.severity = error
## S2952 : Classes should "Dispose" of members from the classes' own "Dispose" methods (category : Critical Bug / default: warning)
## It is possible in an IDisposable to call Dispose on class members from any method, but the contract of Dispose is that it will clean up all unmanaged resources. Move disposing of members to some other method, and you risk resource leaks.
dotnet_diagnostic.S2952.severity = error
## S2953 : Methods named "Dispose" should implement "IDisposable.Dispose" (category : Blocker Code Smell / default: warning)
## IDisposable is an interface implemented by all types which need to provide a mechanism for releasing unmanaged resources.
dotnet_diagnostic.S2953.severity = error
## S3902 : "Assembly.GetExecutingAssembly" should not be called (category : Major Code Smell / default: warning)
## Using Type.Assembly to get the current assembly is nearly free in terms of performance; it’s a simple property access. On the other hand, Assembly.GetExecutingAssembly() can take up to 30 times as long because it walks up the call stack to find the assembly.
dotnet_diagnostic.S3902.severity = error
## S3885 : "Assembly.Load" should be used (category : Major Code Smell / default: warning)
## The parameter to Assembly.Load includes the full specification of the dll to be loaded. Use another method, and you might end up with a dll other than the one you expected.
dotnet_diagnostic.S3885.severity = error
## S1147 : Exit methods should not be called (category : Blocker Code Smell / default: warning)
## Calling Environment.Exit(exitCode) or Application.Exit() terminates the process and returns an exit code to the operating system..
dotnet_diagnostic.S1147.severity = error
## S1215 : "GC.Collect" should not be called (category : Critical Code Smell / default: warning)
## GC.Collect is a method that forces or suggests to the garbage collector to run a collection of objects in the managed heap that are no longer being used and free their memory.
dotnet_diagnostic.S1215.severity = error
## S3971 : "GC.SuppressFinalize" should not be called (category : Major Code Smell / default: warning)
## GC.SuppressFinalize requests that the system not call the finalizer for the specified object. This should only be done when implementing Dispose as part of the Dispose Pattern.
dotnet_diagnostic.S3971.severity = error
## S1696 : NullReferenceException should not be caught (category : Major Code Smell / default: warning)
## Catching NullReferenceException is generally considered a bad practice because it can hide bugs in your code. Instead of catching this exception, you should aim to prevent it. This makes your code more robust and easier to understand. In addition, constantly catching and handling NullReferenceException can lead to performance issues. Exceptions are expensive in terms of system resources, so they should be used cautiously and only for exceptional conditions, not for regular control flow.
dotnet_diagnostic.S1696.severity = error
## S2221 : "Exception" should not be caught (category : Minor Code Smell / default: warning)
## Catching System.Exception seems like an efficient way to handle multiple possible exceptions. Unfortunately, it traps all exception types, including the ones that were not intended to be caught. To prevent any misunderstandings, exception filters should be used. Alternatively, each exception type should be in a separate catch block.
dotnet_diagnostic.S2221.severity = error
## S3981 : Collection sizes and array length comparisons should make sense (category : Major Bug / default: warning)
## The size of a collection and the length of an array are always greater than or equal to zero. Testing it doesn’t make sense, since the result is always true.
dotnet_diagnostic.S3981.severity = error
## S2365 : Properties should not make collection or array copies (category : Critical Code Smell / default: warning)
## Most developers expect property access to be as efficient as field access. However, if a property returns a copy of an array or collection, it will be much slower than a simple field access, contrary to the caller’s likely expectations. Therefore, such properties should be refactored into methods so that callers are not surprised by the unexpectedly poor performance.
dotnet_diagnostic.S2365.severity = error
## S4015 : Inherited member visibility should not be decreased (category : Critical Code Smell / default: warning)
## Decreasing the accessibility level of an inherited method that is not overridable to private will shadow the name of the base method and can lead to confusion.
dotnet_diagnostic.S4015.severity = error
## S3956 : "Generic.List" instances should not be part of public APIs (category : Major Code Smell / default: warning)
## System.Collections.Generic.List{T} is a generic collection that is designed for performance and not inheritance. For example, it does not contain virtual members that make it easier to change the behavior of an inherited class. That means that future attempts to expand the behavior will be spoiled because the extension points simply aren’t there. Instead, one of the following generic collections should be used:
dotnet_diagnostic.S3956.severity = error
## S2068 : Hard-coded credentials are security-sensitive (category : Blocker Security Hotspot / default: warning)
## Because it is easy to extract strings from an application source code or binary, credentials should not be hard-coded. This is particularly true for applications that are distributed or that are open-source.
dotnet_diagnostic.S2068.severity = error
## S4019 : Base class methods should not be hidden (category : Critical Code Smell / default: warning)
## When a method in a derived class has:
dotnet_diagnostic.S4019.severity = error
## S4277 : "Shared" parts should not be created with "new" (category : Critical Bug / default: warning)
## Marking a class with PartCreationPolicy(CreationPolicy.Shared), which is part of Managed Extensibility Framework (MEF), means that a single, shared instance of the exported object will be created. Therefore it doesn’t make sense to create new instances using the constructor and it will most likely result in unexpected behaviours.
dotnet_diagnostic.S4277.severity = error
## S2551 : Shared resources should not be used for locking (category : Critical Bug / default: warning)
## A shared resource refers to a resource or data that can be accessed or modified by multiple threads or concurrent parts of a program. It could be any piece of data, object, file, database connection, or system resource that needs to be accessed or manipulated by multiple parts of a program at the same time.
dotnet_diagnostic.S2551.severity = error
## S3998 : Threads should not lock on objects with weak identity (category : Critical Code Smell / default: warning)
## Objects that can be accessed across application domain boundaries are said to have weak identity. This means that these objects can be considered shared resources outside of the domain, which can be lead to them being accessed or modified by multiple threads or concurrent parts of a program, outside of the domain.
dotnet_diagnostic.S3998.severity = error
## S4070 : Non-flags enums should not be marked with "FlagsAttribute" (category : Major Code Smell / default: warning)
## This rule raises an issue when an externally visible enumeration is marked with FlagsAttribute and one, or more, of its values is not a power of 2 or a combination of the other defined values.
dotnet_diagnostic.S4070.severity = error
## S3358 : Ternary operators should not be nested (category : Major Code Smell / default: warning)
## Nested ternaries are hard to read and can make the order of operations complex to understand.
dotnet_diagnostic.S3358.severity = suggestion
## S4017 : Method signatures should not contain nested generic types (category : Major Code Smell / default: warning)
## A nested type is a type argument that is also a generic type. Calling a method with such a nested type argument requires complicated and confusing code. It should be avoided as much as possible.
dotnet_diagnostic.S4017.severity = suggestion
## S3875 : "operator==" should not be overloaded on reference types (category : Blocker Code Smell / default: warning)
## The use of == to compare two objects is expected to do a reference comparison. That is, it is expected to return true if and only if they are the same object instance. Overloading the operator to do anything else will inevitably lead to the introduction of bugs by callers.
dotnet_diagnostic.S3875.severity = error
## S4143 : Collection elements should not be replaced unconditionally (category : Major Bug / default: warning)
## Storing a value inside a collection at a given key or index and then unconditionally overwriting it without reading the initial value is a case of a "dead store".
dotnet_diagnostic.S4143.severity = error
## S2183 : Integral numbers should not be shifted by zero or more than their number of bits-1 (category : Minor Bug / default: warning)
## The shifting operators are used to do an arithmetic shift to the bits of an integral numeric value, either to the left or the right.
dotnet_diagnostic.S2183.severity = error
## S3060 : "is" should not be used with "this" (category : Blocker Code Smell / default: warning)
## One of the possible ways of performing type-testing is via the is operator: food is Pizza.
dotnet_diagnostic.S3060.severity = error
## S1048 : Finalizers should not throw exceptions (category : Blocker Bug / default: warning)
## The finalizers are used to perform any necessary final clean-up when the garbage collector is collecting a class instance. The programmer has no control over when the finalizer is called; the garbage collector decides when to call it.
dotnet_diagnostic.S1048.severity = error
## S2114 : Collections should not be passed as arguments to their own methods (category : Major Bug / default: warning)
## Passing a collection as an argument to the collection’s own method is a code defect. Doing so might either have unexpected side effects or always have the same result.
dotnet_diagnostic.S2114.severity = error
## S6563 : Use UTC when recording DateTime instants (category : Major Code Smell / default: warning)
## You should avoid recording time instants with the use of property DateTime.Now. The property DateTime.Now returns the current date and time expressed in the machine’s local time without containing any timezone-related information (for example, the offset from Coordinated Universal Time). Not having this information means that if you need to display this DateTime object or use it for computations in another machine placed in a different time zone, you won’t be able to reconstruct it in the second machine’s local time without knowing the origin’s offset. This will likely lead to confusion and potential bugs.
dotnet_diagnostic.S6563.severity = error
## S2701 : Literal boolean values should not be used in assertions (category : Critical Code Smell / default: warning)
## Using literal boolean values in assertions can lead to less readable and less informative unit tests. When a test fails, it’s important to have a clear understanding of what the test was checking and why it failed. Most of the testing frameworks provide more explicit assertion methods that will provide a more helpful error message if the test fails.
dotnet_diagnostic.S2701.severity = error
## S3874 : "out" and "ref" parameters should not be used (category : Critical Code Smell / default: warning)
## Passing a parameter by reference, which is what happens when you use the out or ref parameter modifiers, means that the method will receive a pointer to the argument, rather than the argument itself. If the argument was a value type, the method will be able to change the argument’s values. If it was a reference type, then the method receives a pointer to a pointer, which is usually not what was intended. Even when it is what was intended, this is the sort of thing that’s difficult to get right, and should be used with caution.
dotnet_diagnostic.S3874.severity = error
## S2245 : Using pseudorandom number generators (PRNGs) is security-sensitive (category : Critical Security Hotspot / default: warning)
## Using pseudorandom number generators (PRNGs) is security-sensitive. For example, it has led in the past to the following vulnerabilities:
dotnet_diagnostic.S2245.severity = error
## S106 : Standard outputs should not be used directly to log anything (category : Major Code Smell / default: warning)
## In software development, logs serve as a record of events within an application, providing crucial insights for debugging. When logging, it is essential to ensure that the logs are:
dotnet_diagnostic.S106.severity = error
## S881 : Increment (++) and decrement (--) operators should not be used in a method call or mixed with other operators in an expression (category : Major Code Smell / default: warning)
## The use of increment and decrement operators in method calls or in combination with other arithmetic operators is not recommended, because:
dotnet_diagnostic.S881.severity = error
## S6675 : "Trace.WriteLineIf" should not be used with "TraceSwitch" levels (category : Minor Code Smell / default: warning)
## The Trace.WriteLineIf Method from the System.Diagnostic.Trace facility writes a trace if the condition passed as the first parameter is true.
dotnet_diagnostic.S6675.severity = error
## S6670 : "Trace.Write" and "Trace.WriteLine" should not be used (category : Minor Code Smell / default: warning)
## Trace.Write and Trace.WriteLine methods are writing to the underlying output stream directly, bypassing the trace formatting and filtering performed by TraceListener.TraceEvent implementations. It is preferred to use Trace.TraceError, Trace.TraceWarning, and Trace.TraceInformation methods instead because they call the TraceEvent method which filters the trace output according to the TraceEventType (Error, Warning or Information) and enhance the output with additional information.
dotnet_diagnostic.S6670.severity = error
## S6424 : Interfaces for durable entities should satisfy the restrictions (category : Blocker Code Smell / default: warning)
## The recommended way to access Azure Durable Entities is through generated proxy objects with the help of interfaces.
dotnet_diagnostic.S6424.severity = error
## S1186 : Methods should not be empty (category : Critical Code Smell / default: warning)
## An empty method is generally considered bad practice and can lead to confusion, readability, and maintenance issues. Empty methods bring no functionality and are misleading to others as they might think the method implementation fulfills a specific and identified requirement.
dotnet_diagnostic.S1186.severity = error
## S3261 : Namespaces should not be empty (category : Minor Code Smell / default: warning)
## Namespaces with no lines of code clutter a project and should be removed.
dotnet_diagnostic.S3261.severity = error
## S108 : Nested blocks of code should not be left empty (category : Major Code Smell / default: warning)
## An empty code block is confusing. It will require some effort from maintainers to determine if it is intentional or indicates the implementation is incomplete.
dotnet_diagnostic.S108.severity = error
## S1116 : Empty statements should be removed (category : Minor Code Smell / default: warning)
## Empty statements represented by a semicolon ; are statements that do not perform any operation. They are often the result of a typo or a misunderstanding of the language syntax. It is a good practice to remove empty statements since they don’t add value and lead to confusion and errors.
dotnet_diagnostic.S1116.severity = error
## S5542 : Encryption algorithms should be used with secure mode and padding scheme (category : Critical Vulnerability / default: warning)
## This vulnerability exposes encrypted data to a number of attacks whose goal is to recover the plaintext.
dotnet_diagnostic.S5542.severity = error
## S2291 : Overflow checking should not be disabled for "Enumerable.Sum" (category : Critical Code Smell / default: warning)
## Enumerable.Sum() always executes addition in a checked context, so an OverflowException will be thrown if the value exceeds MaxValue, even if an unchecked context was specified. Therefore, using this method inside an unchecked context will only make the code more confusing, since the behavior will still be checked.
dotnet_diagnostic.S2291.severity = error
## S2344 : Enumeration type names should not have "Flags" or "Enum" suffixes (category : Minor Code Smell / default: warning)
## The information that an enumeration type is actually an enumeration or a set of flags should not be duplicated in its name.
dotnet_diagnostic.S2344.severity = error
## S2342 : Enumeration types should comply with a naming convention (category : Minor Code Smell / default: warning)
## Shared naming conventions allow teams to collaborate efficiently. This rule checks that all enum names match a provided regular expression.
dotnet_diagnostic.S2342.severity = error
## S4016 : Enumeration members should not be named "Reserved" (category : Major Code Smell / default: warning)
## If an enum member’s name contains the word "reserved" it implies it is not currently used and will be change in the future. However changing an enum member is a breaking change and can create significant problems. There is no need to reserve an enum member since a new member can be added in the future, and such an addition will usually not be a breaking change.
dotnet_diagnostic.S4016.severity = error
## S4022 : Enumerations should have "Int32" storage (category : Minor Code Smell / default: warning)
## By default the storage type of an enum is Int32. In most cases it is not necessary to change this. In particular you will not achieve any performance gain by using a smaller data type (e.g. Byte) and may limit future uses.
dotnet_diagnostic.S4022.severity = error
## S1244 : Floating point numbers should not be tested for equality (category : Major Bug / default: warning)
## Floating point numbers in C# (and in most other programming languages) are not precise. They are a binary approximation of the actual value. This means that even if two floating point numbers appear to be equal, they might not be due to the tiny differences in their binary representation.
dotnet_diagnostic.S1244.severity = error
## S2197 : Modulus results should not be checked for direct equality (category : Critical Code Smell / default: warning)
## When the modulus of a negative number is calculated, the result will either be negative or zero. Thus, comparing the modulus of a variable for equality with a positive number (or a negative one) could result in unexpected results.
dotnet_diagnostic.S2197.severity = error
## S4035 : Classes implementing "IEquatable{T}" should be sealed (category : Major Code Smell / default: warning)
## When a class implements the IEquatable{T} interface, it enters a contract that, in effect, states "I know how to compare two instances of type T or any type derived from T for equality.". However if that class is derived, it is very unlikely that the base class will know how to make a meaningful comparison. Therefore that implicit contract is now broken.
dotnet_diagnostic.S4035.severity = suggestion
## S4220 : Events should have proper arguments (category : Major Code Smell / default: warning)
## When raising an event, two arguments are expected by the EventHandler delegate: Sender and event-data. There are three guidelines regarding these parameters:
dotnet_diagnostic.S4220.severity = error
## S3445 : Exceptions should not be explicitly rethrown (category : Major Code Smell / default: warning)
## In C#, the throw statement can be used in two different ways:
dotnet_diagnostic.S3445.severity = error
## S3877 : Exceptions should not be thrown from unexpected methods (category : Blocker Code Smell / default: warning)
## The rule is reporting when an exception is thrown from certain methods and constructors. These methods are expected to behave in a specific way and throwing an exception from them can lead to unexpected behavior and break the calling code.
dotnet_diagnostic.S3877.severity = error
## S4027 : Exceptions should provide standard constructors (category : Minor Code Smell / default: warning)
## Exceptions types should provide the following constructors:
dotnet_diagnostic.S4027.severity = suggestion
## S6667 : Logging in a catch clause should pass the caught exception as a parameter. (category : Minor Code Smell / default: warning)
## This rule raises an issue on logging calls inside a catch clause that does not pass the raised Exception.
dotnet_diagnostic.S6667.severity = error
## S2139 : Exceptions should be either logged or rethrown but not both (category : Major Code Smell / default: warning)
## When an exception is logged and rethrown, the upstream code may not be aware that the exception has already been logged. As a result, the same exception gets logged multiple times, making it difficult to identify the root cause of the issue. This can be particularly problematic in multi-threaded applications where messages from other threads can be interwoven with the repeated log entries.
dotnet_diagnostic.S2139.severity = error
## S3871 : Exception types should be "public" (category : Critical Code Smell / default: warning)
## The point of having custom exception types is to convey more information than is available in standard types. But custom exception types must be public for that to work.
dotnet_diagnostic.S3871.severity = error
## S3984 : Exceptions should not be created without being thrown (category : Major Bug / default: warning)
## Creating a new Exception without actually throwing does not achieve the intended purpose.
dotnet_diagnostic.S3984.severity = error
## S6513 : "ExcludeFromCodeCoverage" attributes should include a justification (category : Minor Code Smell / default: warning)
## The ExcludeFromCodeCoverageAttribute is used to exclude portions of code from code coverage reporting. It is a bad practice to retain code that is not covered by unit tests. In .Net 5, the Justification property was added to the ExcludeFromCodeCoverageAttribute as an opportunity to document the rationale for the exclusion. This rule raises an issue when no such justification is given.
dotnet_diagnostic.S6513.severity = error
## S2077 : Formatting SQL queries is security-sensitive (category : Major Security Hotspot / default: warning)
## Formatted SQL queries can be difficult to maintain, debug and can increase the risk of SQL injection when concatenating untrusted values into the query. However, this rule doesn’t detect SQL injections (unlike rule {rule:csharpsquid:S3649}), the goal is only to highlight complex/formatted queries.
dotnet_diagnostic.S2077.severity = error
## S5042 : Expanding archive files without controlling resource consumption is security-sensitive (category : Critical Security Hotspot / default: warning)
## Successful Zip Bomb attacks occur when an application expands untrusted archive files without controlling the size of the expanded data, which can lead to denial of service. A Zip bomb is usually a malicious archive file of a few kilobytes of compressed data but turned into gigabytes of uncompressed data. To achieve this extreme compression ratio, attackers will compress irrelevant data (eg: a long string of repeated bytes).
dotnet_diagnostic.S5042.severity = error
## S3431 : "[ExpectedException]" should not be used (category : Major Code Smell / default: warning)
## It should be clear to a casual reader what code a test is testing and what results are expected. Unfortunately, that’s not usually the case with the ExpectedException attribute since an exception could be thrown from almost any line in the method.
dotnet_diagnostic.S3431.severity = error
## S1067 : Expressions should not be too complex (category : Critical Code Smell / default: warning)
## The complexity of an expression is defined by the number of &&, || and condition ? ifTrue : ifFalse operators it contains.
dotnet_diagnostic.S1067.severity = error
## S4226 : Extensions should be in separate namespaces (category : Minor Code Smell / default: warning)
## It makes little sense to create an extension method when it is possible to just add that method to the class itself.
dotnet_diagnostic.S4226.severity = none
## S4225 : Extension methods should not extend "object" (category : Minor Code Smell / default: warning)
## ﻿Creating an extension method that extends object is not recommended because it makes the method available on every type. Extensions should be applied at the most specialized level possible, and that is very unlikely to be object.
dotnet_diagnostic.S4225.severity = error
## S2387 : Child class fields should not shadow parent class fields (category : Blocker Code Smell / default: warning)
## This rule is deprecated, and will eventually be removed.
dotnet_diagnostic.S2387.severity = error
## S4025 : Child class fields should not differ from parent class fields only by capitalization (category : Critical Code Smell / default: warning)
## Having a field in a child class with a name that differs from a parent class' field only by capitalization is sure to cause confusion. Such child class fields should be renamed.
dotnet_diagnostic.S4025.severity = error
## S2933 : Fields that are only assigned in the constructor should be "readonly" (category : Major Code Smell / default: warning)
## readonly fields can only be assigned in a class constructor. If a class has a field that’s not marked readonly but is only set in the constructor, it could cause confusion about the field’s intended use. To avoid confusion, such fields should be marked readonly to make their intended use explicit, and to prevent future maintainers from inadvertently changing their use.
dotnet_diagnostic.S2933.severity = error
## S2357 : Fields should be private (category : Major Code Smell / default: warning)
## Fields should not be part of an API, and therefore should always be private. Indeed, they cannot be added to an interface for instance, and validation cannot be added later on without breaking backward compatibility. Instead, developers should encapsulate their fields into properties. Explicit property getters and setters can be introduced for validation purposes or to smooth the transition to a newer system.
dotnet_diagnostic.S2357.severity = error
## S1104 : Fields should not have public accessibility (category : Minor Code Smell / default: warning)
## Public fields in public classes do not respect the encapsulation principle and have three main disadvantages:
dotnet_diagnostic.S1104.severity = error
## S104 : Files should not have too many lines of code (category : Major Code Smell / default: warning)
## When a source file grows too much, it can accumulate numerous responsibilities and become challenging to understand and maintain.
dotnet_diagnostic.S104.severity = error
## S9999-metadata : File metadata generator (category :  / default: warning)
dotnet_diagnostic.S9999-metadata.severity = error
## S113 : Files should end with a newline (category : Minor Code Smell / default: warning)
## Some tools work better when files end with an empty line.
dotnet_diagnostic.S113.severity = error
## S3880 : Finalizers should not be empty (category : Major Code Smell / default: warning)
## Finalizers come with a performance cost due to the overhead of tracking the life cycle of objects. An empty one is consequently costly with no benefit or justification.
dotnet_diagnostic.S3880.severity = error
## S6602 : "Find" method should be used instead of the "FirstOrDefault" extension (category : Minor Code Smell / default: warning)
## Both the List.Find method and IEnumerable.FirstOrDefault method can be used to find the first element that satisfies a given condition in a collection. However, List.Find can be faster than IEnumerable.FirstOrDefault for List objects. For small collections, the performance difference may be minor, but for large collections, it can make a noticeable difference. The same applies for ImmutableList and arrays too.
dotnet_diagnostic.S6602.severity = error
## S2345 : Flags enumerations should explicitly initialize all their members (category : Minor Bug / default: warning)
## When you annotate an Enum with the Flags attribute, you must not rely on the values that are automatically set by the language to the Enum members, but you should define the enumeration constants in powers of two (1, 2, 4, 8, and so on). Automatic value initialization will set the first member to zero and increment the value by one for each subsequent member. As a result, you won’t be able to use the enum members with bitwise operators.
dotnet_diagnostic.S2345.severity = error
## S2346 : Flags enumerations zero-value members should be named "None" (category : Critical Code Smell / default: warning)
## An enumeration can be decorated with the FlagsAttribute to indicate that it can be used as a bit field: a set of flags, that can be independently set and reset.
dotnet_diagnostic.S2346.severity = error
## S3217 : "Explicit" conversions of "foreach" loops should not be used (category : Critical Code Smell / default: warning)
## The foreach statement was introduced in the C# language prior to generics to make it easier to work with the non-generic collections available at that time such as ArrayList. The foreach statements allow you to downcast elements of a collection of Objects to any other type.
dotnet_diagnostic.S3217.severity = error
## S2252 : For-loop conditions should be true at least once (category : Major Bug / default: warning)
## A for loop is a fundamental programming construct used to execute a block of code repeatedly. However, if the loop’s condition is false before the first iteration, the loop will never execute.
dotnet_diagnostic.S2252.severity = error
## S127 : "for" loop stop conditions should be invariant (category : Major Code Smell / default: warning)
## A for loop stop condition should test the loop counter against an invariant value (i.e. one that is true at both the beginning and ending of every loop iteration). Ideally, this means that the stop condition is set to a local variable just before the loop begins.
dotnet_diagnostic.S127.severity = error
## S1994 : "for" loop increment clauses should modify the loops' counters (category : Critical Code Smell / default: warning)
## The for loop is designed to iterate over a range using a counter variable, with the counter being updated in the loop’s increment section. Misusing this structure can lead to issues such as infinite loops if the counter is not updated correctly. If this is intentional, use a while or do while loop instead of a for loop.
dotnet_diagnostic.S1994.severity = error
## S2251 : A "for" loop update clause should move the counter in the right direction (category : Major Bug / default: warning)
## A for loop with a counter that moves in the wrong direction, away from the stop condition, is not an infinite loop. Because of wraparound, the loop will eventually reach its stop condition, but in doing so, it will probably run more times than anticipated, potentially causing unexpected behavior.
dotnet_diagnostic.S2251.severity = error
## S3376 : Attribute, EventArgs, and Exception type names should end with the type being extended (category : Minor Code Smell / default: warning)
## Adherence to the standard naming conventions makes your code not only more readable, but more usable. For instance, class FirstAttribute : Attribute can be used simply with First, but you must use the full name for class AttributeOne : Attribute.
dotnet_diagnostic.S3376.severity = error
## S1541 : Methods and properties should not be too complex (category : Critical Code Smell / default: warning)
## The cyclomatic complexity of methods and properties should not exceed a defined threshold. Complex code can perform poorly and will in any case be difficult to understand and therefore to maintain.
dotnet_diagnostic.S1541.severity = error
## S134 : Control flow statements "if", "switch", "for", "foreach", "while", "do"  and "try" should not be nested too deeply (category : Critical Code Smell / default: warning)
## Nested control flow statements if, switch, for, foreach, while, do, and try are often key ingredients in creating what’s known as "Spaghetti code". This code smell can make your program difficult to understand and maintain.
dotnet_diagnostic.S134.severity = error
## S3464 : Type inheritance should not be recursive (category : Blocker Bug / default: warning)
## Recursion is a technique used to define a problem in terms of the problem itself, usually in terms of a simpler version of the problem itself.
dotnet_diagnostic.S3464.severity = error
## S6672 : Generic logger injection should match enclosing type (category : Minor Code Smell / default: warning)
## In most logging frameworks, it’s good practice to set the logger name to match its enclosing type, as enforced by {rule:csharpsquid:S3416}.
dotnet_diagnostic.S6672.severity = error
## S2934 : Property assignments should not be made for "readonly" fields not constrained to reference types (category : Minor Bug / default: warning)
## While the properties of a readonly reference type field can still be changed after initialization, those of a readonly value type field, such as a struct, cannot.
dotnet_diagnostic.S2934.severity = error
## S2955 : Generic parameters not constrained to reference types should not be compared to "null" (category : Minor Bug / default: warning)
## In C#, without constraints on a generic type parameter, both reference and value types can be passed. However, comparing this type parameter to null can be misleading as value types, like struct, can never be null.
dotnet_diagnostic.S2955.severity = error
## S3246 : Generic type parameters should be co/contravariant when possible (category : Major Code Smell / default: warning)
## In the interests of making code as usable as possible, interfaces and delegates with generic parameters should use the out and in modifiers when possible to make the interfaces and delegates covariant and contravariant, respectively.
dotnet_diagnostic.S3246.severity = error
## S4018 : All type parameters should be used in the parameter list to enable type inference (category : Minor Code Smell / default: warning)
## Type inference enables the call of a generic method without explicitly specifying its type arguments. This is not possible when a parameter type is missing from the argument list.
dotnet_diagnostic.S4018.severity = suggestion
## S2326 : Unused type parameters should be removed (category : Major Code Smell / default: warning)
## Type parameters that aren’t used are dead code, which can only distract and possibly confuse developers during maintenance. Therefore, unused type parameters should be removed.
dotnet_diagnostic.S2326.severity = error
## S3249 : Classes directly extending "object" should not call "base" in "GetHashCode" or "Equals" (category : Major Bug / default: warning)
## Making a base call when overriding a method is generally a good idea, but not in the case of GetHashCode and Equals for classes that directly extend Object. These methods are based on the object’s reference, meaning that no two objects that use those base methods can be equal or have the same hash.
dotnet_diagnostic.S3249.severity = error
## S2328 : "GetHashCode" should not reference mutable fields (category : Minor Bug / default: warning)
## GetHashCode is used to file an object in a Dictionary or Hashtable. If GetHashCode uses non-readonly fields and those fields change after the object is stored, the object immediately becomes mis-filed in the Hashtable. Any subsequent test to see if the object is in the Hashtable will return a false negative.
dotnet_diagnostic.S2328.severity = error
## S2219 : Runtime type checking should be simplified (category : Minor Code Smell / default: warning)
## To check the type of an object there are several options:
dotnet_diagnostic.S2219.severity = error
## S907 : "goto" statement should not be used (category : Major Code Smell / default: warning)
## goto is an unstructured control flow statement. It makes code less readable and maintainable. Structured control flow statements such as if, for, while, continue or break should be used instead.
dotnet_diagnostic.S907.severity = error
## S3397 : "base.Equals" should not be used to check for reference equality in "Equals" if "base" is not "object" (category : Minor Bug / default: warning)
## object.Equals() overrides can be optimized by checking first for reference equality between this and the parameter. This check can be implemented by calling object.ReferenceEquals() or base.Equals(), where base is object. However, using base.Equals() is a maintenance hazard because while it works if you extend Object directly, if you introduce a new base class that overrides Equals, it suddenly stops working.
dotnet_diagnostic.S3397.severity = error
## S1313 : Using hardcoded IP addresses is security-sensitive (category : Major Security Hotspot / default: warning)
## Hardcoding IP addresses is security-sensitive. It has led in the past to the following vulnerabilities:
dotnet_diagnostic.S1313.severity = error
## S1066 : Mergeable "if" statements should be combined (category : Major Code Smell / default: warning)
## Nested code - blocks of code inside blocks of code - is eventually necessary, but increases complexity. This is why keeping the code as flat as possible, by avoiding unnecessary nesting, is considered a good practice.
dotnet_diagnostic.S1066.severity = error
## S3881 : "IDisposable" should be implemented correctly (category : Major Code Smell / default: warning)
## The IDisposable interface is a mechanism to release unmanaged resources, if not implemented correctly this could result in resource leaks or more severe bugs.
dotnet_diagnostic.S3881.severity = error
## S3925 : "ISerializable" should be implemented correctly (category : Major Code Smell / default: warning)
## The ISerializable interface is the mechanism to control the type serialization process. If not implemented correctly this could result in an invalid serialization and hard-to-detect bugs.
dotnet_diagnostic.S3925.severity = error
## S3927 : Serialization event handlers should be implemented correctly (category : Major Bug / default: warning)
## Serialization event handlers that don’t have the correct signature will not be called, bypassing augmentations to automated serialization and deserialization events.
dotnet_diagnostic.S3927.severity = error
## S3927 : Serialization event handlers should be implemented correctly (category : Major Bug / default: warning)
## Serialization event handlers that don’t have the correct signature will not be called, bypassing augmentations to automated serialization and deserialization events.
dotnet_diagnostic.S3927.severity = error
## S3973 : A conditionally executed single line should be denoted by indentation (category : Critical Code Smell / default: warning)
## When the line immediately after conditional statements has neither curly braces nor indentation, the intent of the code is unclear and perhaps not executed as expected. Additionally, such code is confusing to maintainers.
dotnet_diagnostic.S3973.severity = error
## S2692 : "IndexOf" checks should not be for positive numbers (category : Critical Code Smell / default: warning)
## Most checks against an IndexOf value compare it with -1 because 0 is a valid index.
dotnet_diagnostic.S2692.severity = error
## S2190 : Loops and recursions should not be infinite (category : Blocker Bug / default: warning)
## Having an infinite loop or recursion will lead to a program failure or a program never finishing the execution.
dotnet_diagnostic.S2190.severity = error
## S3444 : Interfaces should not simply inherit from base interfaces with colliding members (category : Minor Code Smell / default: warning)
## When an interface inherits from two interfaces that both define a member with the same name, trying to access that member through the derived interface will result in the compiler error CS0229 Ambiguity between 'IBase1.SomeProperty' and 'IBase2.SomeProperty'.
dotnet_diagnostic.S3444.severity = error
## S3963 : "static" fields should be initialized inline (category : Minor Code Smell / default: warning)
## When a static constructor serves no other purpose that initializing static fields, it comes with an unnecessary performance cost because the compiler generates a check before each static method or instance constructor invocation.
dotnet_diagnostic.S3963.severity = error
## S5766 : Deserializing objects without performing data validation is security-sensitive (category : Major Security Hotspot / default: warning)
## Deserialization process extracts data from the serialized representation of an object and reconstruct it directly, without calling constructors. Thus, data validation implemented in constructors can be bypassed if serialized objects are controlled by an attacker.
dotnet_diagnostic.S5766.severity = error
## S5547 : Cipher algorithms should be robust (category : Critical Vulnerability / default: warning)
## This vulnerability makes it possible that the cleartext of the encrypted message might be recoverable without prior knowledge of the key.
dotnet_diagnostic.S5547.severity = error
## S5445 : Insecure temporary file creation methods should not be used (category : Critical Vulnerability / default: warning)
## Temporary files are considered insecurely created when the file existence check is performed separately from the actual file creation. Such a situation can occur when creating temporary files using normal file handling functions or when using dedicated temporary file handling functions that are not atomic.
dotnet_diagnostic.S5445.severity = error
## S6605 : Collection-specific "Exists" method should be used instead of the "Any" extension (category : Minor Code Smell / default: warning)
## Both the List.Exists method and IEnumerable.Any method can be used to find the first element that satisfies a predicate in a collection. However, List.Exists can be faster than IEnumerable.Any for List objects, as well as requires significantly less memory. For small collections, the performance difference may be negligible, but for large collections, it can be noticeable. The same applies to ImmutableList and arrays too.
dotnet_diagnostic.S6605.severity = none # This rule is deprecated, and will eventually be removed.
## S6617 : "Contains" should be used instead of "Any" for simple equality checks (category : Minor Code Smell / default: warning)
## When testing if a collection contains a specific item by simple equality, both ICollection.Contains(T item) and IEnumerable.Any(x ⇒ x == item) can be used. However, Any searches the data structure in a linear manner using a foreach loop, whereas Contains is considerably faster in some collection types, because of the underlying implementation. More specifically:
dotnet_diagnostic.S6617.severity = error
## S4039 : Interface methods should be callable by derived types (category : Critical Code Smell / default: warning)
## When a base type explicitly implements a public interface method, that method is only accessible in derived types through a reference to the current instance (namely this). If the derived type explicitly overrides that interface method, the base implementation becomes inaccessible.
dotnet_diagnostic.S4039.severity = error
## S1944 : Invalid casts should be avoided (category : Critical Code Smell / default: warning)
## A cast is an explicit conversion, which is a way to tell the compiler the intent to convert from one type to another.
dotnet_diagnostic.S1944.severity = error
## S3220 : Method calls should not resolve ambiguously to overloads with "params" (category : Minor Code Smell / default: warning)
## The rules for method resolution are complex and perhaps not properly understood by all coders. The params keyword can make method declarations overlap in non-obvious ways, so that slight changes in the argument types of an invocation can resolve to different methods.
dotnet_diagnostic.S3220.severity = error
## S6798 : [JSInvokable] attribute should only be used on public methods (category : Major Bug / default: warning)
## In Blazor, the [JSInvokable] attribute is used to annotate a method, enabling it to be invoked from JavaScript code. The prerequisite for this functionality is that the method must be declared as public. Otherwise, a runtime error will be triggered when an attempt is made to call the method from JavaScript.
dotnet_diagnostic.S6798.severity = error
## S5659 : JWT should be signed and verified with strong cipher algorithms (category : Critical Vulnerability / default: warning)
## This vulnerability allows forging of JSON Web Tokens to impersonate other users.
dotnet_diagnostic.S5659.severity = error
## S4433 : LDAP connections should be authenticated (category : Critical Vulnerability / default: warning)
## Lightweight Directory Access Protocol (LDAP) servers provide two main authentication methods: the SASL and Simple ones. The Simple Authentication method also breaks down into three different mechanisms:
dotnet_diagnostic.S4433.severity = error
## S103 : Lines should not be too long (category : Major Code Smell / default: warning)
## Scrolling horizontally to see a full line of code lowers the code readability.
dotnet_diagnostic.S103.severity = error
## S6613 : "First" and "Last" properties of "LinkedList" should be used instead of the "First()" and "Last()" extension methods (category : Minor Code Smell / default: warning)
## Both the Enumerable.First extension method and the LinkedList{T}.First property can be used to find the first value in a LinkedList{T}. However, LinkedList{T}.First is much faster than Enumerable.First. For small collections, the performance difference may be minor, but for large collections, it can be noticeable. The same applies for the Last property as well.
dotnet_diagnostic.S6613.severity = error
## S818 : Literal suffixes should be upper case (category : Minor Code Smell / default: warning)
## Using upper case literal suffixes removes the potential ambiguity between "1" (digit 1) and "l" (letter el) for declaring literals.
dotnet_diagnostic.S818.severity = error
## S2445 : Blocks should be synchronized on read-only fields (category : Major Bug / default: warning)
## Locking on a class field synchronizes not on the field itself, but on the object assigned to it. Thus, there are some good practices to follow to avoid problems related to thread synchronization.
dotnet_diagnostic.S2445.severity = error
## S6507 : Blocks should not be synchronized on local variables (category : Major Bug / default: warning)
## Locking on a local variable can undermine synchronization because two different threads running the same method in parallel will potentially lock on different instances of the same object, allowing them to access the synchronized block at the same time.
dotnet_diagnostic.S6507.severity = error
## S9999-log : Log generator (category :  / default: warning)
dotnet_diagnostic.S9999-log.severity = error
## S6669 : Logger field or property name should comply with a naming convention (category : Minor Code Smell / default: warning)
## Sharing some naming conventions is a key point to make it possible for a team to efficiently collaborate. This rule checks that the logger field or property name matches a provided regular expression.
dotnet_diagnostic.S6669.severity = error
## S3416 : Loggers should be named for their enclosing types (category : Minor Code Smell / default: warning)
## It is a well-established convention to name each logger after its enclosing type. This rule raises an issue when the convention is not respected.
dotnet_diagnostic.S3416.severity = error
## S6668 : Logging arguments should be passed to the correct parameter (category : Minor Code Smell / default: warning)
## Most logging frameworks have methods that take a log level, an event ID or an exception as a separate input next to the log format and its arguments. There is a high chance that if the log level, the event ID or the exception are passed as the arguments to the message format, it was a mistake. This rule is going to raise in that scenario.
dotnet_diagnostic.S6668.severity = error
## S3267 : Loops should be simplified with "LINQ" expressions (category : Minor Code Smell / default: warning)
## When a loop is filtering, selecting or aggregating, those functions can be handled with a clearer, more concise LINQ expression instead.
dotnet_diagnostic.S3267.severity = error
## S2612 : Setting loose file permissions is security-sensitive (category : Major Security Hotspot / default: warning)
## In Unix, "others" class refers to all users except the owner of the file and the members of the group assigned to this file.
dotnet_diagnostic.S2612.severity = error
## S2184 : Results of integer division should not be assigned to floating point variables (category : Minor Bug / default: warning)
## When division is performed on ints, the result will always be an int. You can assign that result to a double, float or decimal with automatic type conversion, but having started as an int, the result will likely not be what you expect. If the result of int division is assigned to a floating-point variable, precision will have been lost before the assignment. Instead, at least one operand should be cast or promoted to the final type before the operation takes place.
dotnet_diagnostic.S2184.severity = error
## S109 : Magic numbers should not be used (category : Major Code Smell / default: warning)
## A magic number is a hard-coded numerical value that may lack context or meaning. They should not be used because they can make the code less readable and maintainable.
dotnet_diagnostic.S109.severity = error
## S3904 : Assemblies should have version information (category : Critical Code Smell / default: warning)
## The AssemblyVersion attribute is used to specify the version number of an assembly. An assembly is a compiled unit of code, which can be marked with a version number by applying the attribute to an assembly’s source code file.
dotnet_diagnostic.S3904.severity = error
## S3990 : Assemblies should be marked as CLS compliant (category : Major Code Smell / default: warning)
## Assemblies should conform with the Common Language Specification (CLS) in order to be usable across programming languages. To be compliant an assembly has to indicate it with System.CLSCompliantAttribute.
dotnet_diagnostic.S3990.severity = error
## S3992 : Assemblies should explicitly specify COM visibility (category : Major Code Smell / default: warning)
## Assemblies should explicitly indicate whether they are meant to be COM visible or not. If the ComVisibleAttribute is not present, the default is to make the content of the assembly visible to COM clients.
dotnet_diagnostic.S3992.severity = error
## S4026 : Assemblies should be marked with "NeutralResourcesLanguageAttribute" (category : Minor Code Smell / default: warning)
## It is important to inform the ResourceManager of the language used to display the resources of the neutral culture for an assembly. This improves lookup performance for the first resource loaded.
dotnet_diagnostic.S4026.severity = error
## S4210 : Windows Forms entry points should be marked with STAThread (category : Major Bug / default: warning)
## When an assembly uses Windows Forms (classes and interfaces from the System.Windows.Forms namespace) its entry point should be marked with the STAThreadAttribute to indicate that the threading model should be "Single-Threaded Apartment" (STA) which is the only one supported by Windows Forms.
dotnet_diagnostic.S4210.severity = error
## S3052 : Members should not be initialized to default values (category : Minor Code Smell / default: warning)
## The compiler automatically initializes class fields, auto-properties and events to their default values before setting them with any initialization values, so there is no need to explicitly set a member to its default value. Further, under the logic that cleaner code is better code, it’s considered poor style to do so.
dotnet_diagnostic.S3052.severity = error
## S3604 : Member initializer values should not be redundant (category : Minor Code Smell / default: warning)
## Fields, properties and events can be initialized either inline or in the constructor. Initializing them inline and in the constructor at the same time is redundant; the inline initialization will be overridden.
dotnet_diagnostic.S3604.severity = error
## S1185 : Overriding members should do more than simply call the same member in the base class (category : Minor Code Smell / default: warning)
## Overriding a method just to call the same method from the base class without performing any other actions is useless and misleading. The only time this is justified is in sealed overriding methods, where the effect is to lock in the parent class behavior. This rule ignores overrides of Equals and GetHashCode.
dotnet_diagnostic.S1185.severity = error
## S3218 : Inner class members should not shadow outer class "static" or type members (category : Critical Code Smell / default: warning)
## Naming the members of an inner class the same as the static members of its enclosing class is possible but generally considered a bad practice. That’s because maintainers may be confused about which members are being used in a given context. Instead the inner class member should be given distinct and descriptive name, and all references to it should be updated accordingly.
dotnet_diagnostic.S3218.severity = error
## S2325 : Methods and properties that don't access instance data should be static (category : Minor Code Smell / default: warning)
## Methods and properties that don’t access instance data should be marked as static for the following reasons:
dotnet_diagnostic.S2325.severity = error
## S4211 : Members should not have conflicting transparency annotations (category : Major Vulnerability / default: warning)
## Transparency attributes in the .NET Framework, designed to protect security-critical operations, can lead to ambiguities and vulnerabilities when declared at different levels such as both for the class and a method.
dotnet_diagnostic.S4211.severity = error
## S6678 : Use PascalCase for named placeholders (category : Minor Code Smell / default: warning)
## Within a message template each named placeholder should be in PascalCase.
dotnet_diagnostic.S6678.severity = error
## S6673 : Log message template placeholders should be in the right order (category : Major Code Smell / default: warning)
## The positions of arguments in a logging call should match the positions of their message template placeholders.
dotnet_diagnostic.S6673.severity = error
## S6677 : Message template placeholders should be unique (category : Major Bug / default: warning)
## Named placeholders in message templates should be unique. The meaning of the named placeholders is to store the value of the provided argument under that name, enabling easier log querying. Since the named placeholder is used multiple times, it cannot store the different values uniquely with each name hence not serving its original purpose. There can be different behaviours when using the same named placeholder multiple times:
dotnet_diagnostic.S6677.severity = error
## S6674 : Log message template should be syntactically correct (category : Critical Bug / default: warning)
## A message template must conform to the specification. The rule raises an issue if the template string violates the template string grammar.
dotnet_diagnostic.S6674.severity = error
## S3427 : Method overloads with default parameter values should not overlap (category : Blocker Code Smell / default: warning)
## The rules for method resolution can be complex and may not be fully understood by all developers. The situation becomes even more challenging when dealing with method overloads that have optional parameter values.
dotnet_diagnostic.S3427.severity = error
## S4136 : Method overloads should be grouped together (category : Minor Code Smell / default: warning)
## For clarity, all overloads of the same method should be grouped together. That lets both users and maintainers quickly understand all the current available options.
dotnet_diagnostic.S4136.severity = error
## S3600 : "params" should not be introduced on overrides (category : Critical Code Smell / default: warning)
## Adding params to a method override has no effect. The compiler accepts it, but the callers won’t be able to benefit from the added modifier.
dotnet_diagnostic.S3600.severity = error
## S1006 : Method overrides should not change parameter defaults (category : Critical Code Smell / default: warning)
## Default arguments are determined by the static type of the object.
dotnet_diagnostic.S1006.severity = error
## S3262 : "params" should be used on overrides (category : Major Code Smell / default: warning)
## Overriding methods automatically inherit the params behavior. To ease readability, this modifier should be explicitly used in the overriding method as well.
dotnet_diagnostic.S3262.severity = error
## S3450 : Parameters with "[DefaultParameterValue]" attributes should also be marked "[Optional]" (category : Minor Code Smell / default: warning)
## There is no point in providing a default value for a parameter if callers are required to provide a value for it anyway. Thus, [DefaultParameterValue] should always be used in conjunction with [Optional].
dotnet_diagnostic.S3450.severity = error
## S1172 : Unused method parameters should be removed (category : Major Code Smell / default: warning)
## A typical code smell known as unused function parameters refers to parameters declared in a function but not used anywhere within the function’s body. While this might seem harmless at first glance, it can lead to confusion and potential errors in your code. Disregarding the values passed to such parameters, the function’s behavior will be the same, but the programmer’s intention won’t be clearly expressed anymore. Therefore, removing function parameters that are not being utilized is considered best practice.
dotnet_diagnostic.S1172.severity = error
## S4261 : Methods should be named according to their synchronicities (category : Minor Code Smell / default: warning)
## According to the Task-based Asynchronous Pattern (TAP), methods returning either a System.Threading.Tasks.Task or a System.Threading.Tasks.Task{TResult} are considered "asynchronous". Such methods should use the Async suffix. Conversely methods which do not return such Tasks should not have an "Async" suffix in their names.
dotnet_diagnostic.S4261.severity = error
## S3400 : Methods should not return constants (category : Minor Code Smell / default: warning)
## There’s no point in forcing the overhead of a method call for a method that always returns the same constant value. Even worse, the fact that a method call must be made will likely mislead developers who call the method thinking that something more is done. Declare a constant instead.
dotnet_diagnostic.S3400.severity = error
## S4144 : Methods should not have identical implementations (category : Major Code Smell / default: warning)
## Two methods having the same implementation are suspicious. It might be that something else was intended. Or the duplication is intentional, which becomes a maintenance burden.
dotnet_diagnostic.S4144.severity = error
## S138 : Functions should not have too many lines of code (category : Major Code Smell / default: warning)
## A function that grows too large tends to aggregate too many responsibilities.
dotnet_diagnostic.S138.severity = error
## S138 : Functions should not have too many lines of code (category : Major Code Smell / default: warning)
## A function that grows too large tends to aggregate too many responsibilities.
dotnet_diagnostic.S138.severity = error
## S9999-metrics : Metrics calculator (category :  / default: warning)
dotnet_diagnostic.S9999-metrics.severity = error
## S2681 : Multiline blocks should be enclosed in curly braces (category : Major Code Smell / default: warning)
## Having inconsistent indentation and omitting curly braces from a control structure, such as an if statement or for loop, is misleading and can induce bugs.
dotnet_diagnostic.S2681.severity = error
## S1659 : Multiple variables should not be declared on the same line (category : Minor Code Smell / default: warning)
## Declaring multiple variable on one line is difficult to read.
dotnet_diagnostic.S1659.severity = error
## S3887 : Mutable, non-private fields should not be "readonly" (category : Minor Bug / default: warning)
## Using the readonly keyword on a field means it can’t be changed after initialization. However, that’s only partly true when applied to collections or arrays. The readonly keyword enforces that another instance can’t be assigned to the field, but it cannot keep the contents from being updated. In practice, the field value can be changed, and the use of readonly on such a field is misleading, and you’re likely not getting the behavior you expect.
dotnet_diagnostic.S3887.severity = error
## S2386 : Mutable fields should not be "public static" (category : Minor Code Smell / default: warning)
## public static mutable fields of classes which are accessed directly should be protected to the degree possible. This can be done by reducing the accessibility of the field or by changing the return type to an immutable type.
dotnet_diagnostic.S2386.severity = error
## S2302 : "nameof" should be used (category : Critical Code Smell / default: warning)
## Because parameter names could be changed during refactoring, they should not be spelled out literally in strings. Instead, use nameof(), and the string that’s output will always be correct.
dotnet_diagnostic.S2302.severity = error
## S4200 : Native methods should be wrapped (category : Major Code Smell / default: warning)
## Native methods are functions that reside in libraries outside the .NET runtime. Calling them is helpful for interoperability with applications and libraries written in other programming languages, mainly when performing platform-specific operations. However, doing so comes with additional risks since it means stepping out of the memory-safety model of the runtime. It is therefore highly recommended to take extra steps, like input validation, when invoking native methods. Making the native method private and providing a wrapper that performs these additional steps is the best way to do so.
dotnet_diagnostic.S4200.severity = error
## S1199 : Nested code blocks should not be used (category : Minor Code Smell / default: warning)
## Nested code blocks create new scopes where variables declared within are inaccessible from the outside, and their lifespan ends with the block.
dotnet_diagnostic.S1199.severity = error
## S1163 : Exceptions should not be thrown in finally blocks (category : Critical Code Smell / default: warning)
## If an exception is already being thrown within the try block or caught in a catch block, throwing another exception in the finally block will override the original exception. This means that the original exception’s message and stack trace will be lost, potentially making it challenging to diagnose and troubleshoot the root cause of the problem.
dotnet_diagnostic.S1163.severity = error
## S4586 : Non-async "Task/Task{T}" methods should not return null (category : Critical Bug / default: warning)
## Returning null from a non-async Task/Task{TResult} method will cause a NullReferenceException at runtime if the method is awaited. This problem can be avoided by returning Task.CompletedTask or Task.FromResult{TResult}(null) respectively.
dotnet_diagnostic.S4586.severity = error
## S3260 : Non-derived "private" classes and records should be "sealed" (category : Minor Code Smell / default: warning)
## Classes and records with either private or file access modifiers aren’t visible outside of their assemblies or files, so if they’re not extended inside their scope, they should be made explicitly non-extensible with the addition of the sealed keyword.
dotnet_diagnostic.S3260.severity = error
## S3265 : Non-flags enums should not be used in bitwise operations (category : Critical Code Smell / default: warning)
## Enumerations are commonly used to identify distinct elements from a set of values.
dotnet_diagnostic.S3265.severity = error
## S4040 : Strings should be normalized to uppercase (category : Minor Code Smell / default: warning)
## Certain characters, once normalized to lowercase, cannot make a round trip. That is, they can not be converted from one locale to another and then accurately restored to their original characters.
dotnet_diagnostic.S4040.severity = error
## S3459 : Unassigned members should be removed (category : Minor Code Smell / default: warning)
## Fields and auto-properties that are never assigned to hold the default values for their types. They are either pointless code or, more likely, mistakes.
dotnet_diagnostic.S3459.severity = error
## S3937 : Number patterns should be regular (category : Critical Code Smell / default: warning)
## The use of punctuation characters to separate subgroups in a number can make the number more readable. For instance consider 1,000,000,000 versus 1000000000. But when the grouping is irregular, such as 1,000,00,000; it indicates an error.
dotnet_diagnostic.S3937.severity = error
## S1848 : Objects should not be created to be dropped immediately without being used (category : Major Bug / default: warning)
## Creating objects that are not used is a vulnerability that can lead to unexpected behavior.
dotnet_diagnostic.S1848.severity = error
## S1123 : "Obsolete" attributes should include explanations (category : Major Code Smell / default: warning)
## The Obsolete attribute can be applied with or without a message argument. Marking something Obsolete without including advice on why it’s obsolete or what to use instead will lead maintainers to waste time trying to figure those things out.
dotnet_diagnostic.S1123.severity = error
## S1133 : Deprecated code should be removed (category : Info Code Smell / default: warning)
## This rule is meant to be used as a way to track code which is marked as being deprecated. Deprecated code should eventually be removed.
dotnet_diagnostic.S1133.severity = error
## S4069 : Operator overloads should have named alternatives (category : Minor Code Smell / default: warning)
## Operator overloading is convenient but unfortunately not portable across languages. To be able to access the same functionality from another language you need to provide an alternate named method following the convention:
dotnet_diagnostic.S4069.severity = error
## S4050 : Operators should be overloaded consistently (category : Major Code Smell / default: warning)
## When overloading some arithmetic operator overloads, it is very important to make sure that all related operators and methods are consistent in their implementation.
dotnet_diagnostic.S4050.severity = error
## S3466 : Optional parameters should be passed to "base" calls (category : Major Bug / default: warning)
## When optional parameter values are not passed to base method calls, the value passed in by the caller is ignored. This can cause the function to behave differently than expected, leading to errors and making the code difficult to debug.
dotnet_diagnostic.S3466.severity = error
## S3451 : "[DefaultValue]" should not be used when "[DefaultParameterValue]" is meant (category : Critical Code Smell / default: warning)
## DefaultValue does not make the compiler set the default value, as its name may suggest. What you probably wanted to use is DefaultParameterValue.
dotnet_diagnostic.S3451.severity = error
## S3447 : "[Optional]" should not be used on "ref" or "out" parameters (category : Critical Code Smell / default: warning)
## The use of ref or out in combination with Optional attribute is both confusing and contradictory. [Optional] indicates that the parameter doesn’t have to be provided, while out and ref mean that the parameter will be used to return data to the caller (ref additionally indicates that the parameter may also be used to pass data into the method).
dotnet_diagnostic.S3447.severity = error
## S3169 : Multiple "OrderBy" calls should not be used (category : Major Code Smell / default: warning)
## There’s no point in chaining multiple OrderBy calls in a LINQ; only the last one will be reflected in the result because each subsequent call completely reorders the list. Thus, calling OrderBy multiple times is a performance issue as well, because all of the sorting will be executed, but only the result of the last sort will be kept.
dotnet_diagnostic.S3169.severity = error
## S1206 : "Equals(Object)" and "GetHashCode()" should be overridden in pairs (category : Minor Bug / default: warning)
## Suppose you override Object.Equals in a type, you must also override Object.GetHashCode. If two objects are equal according to the Equals method, then calling GetHashCode on each of them must yield the same integer. If this is not the case, many collections, such as a Hashtable or a Dictionary won’t handle class instances correctly.
dotnet_diagnostic.S1206.severity = error
## S1226 : Method parameters, caught exceptions and foreach variables' initial values should not be ignored (category : Minor Bug / default: warning)
## While it is technically correct to assign to parameters from within method bodies, doing so before the parameter value is read is likely a bug. Instead, initial values of parameters, caught exceptions, and foreach parameters should be, if not treated as final, then at least read before reassignment.
dotnet_diagnostic.S1226.severity = error
## S927 : Parameter names should match base declaration and other partial definitions (category : Critical Code Smell / default: warning)
## Parameters are part of the method signature and its identity.
dotnet_diagnostic.S927.severity = error
## S3872 : Parameter names should not duplicate the names of their methods (category : Minor Code Smell / default: warning)
## The name of a method should communicate what it does, and the names of its parameters should indicate how they’re used. If a method and its parameter have the same name it is an indication that one of these rules of thumb has been broken, if not both. Even if by some trick of language that’s not the case, it is still likely to confuse callers and maintainers.
dotnet_diagnostic.S3872.severity = error
## S2234 : Arguments should be passed in the same order as the method parameters (category : Major Code Smell / default: warning)
## Calling a method with argument variables whose names match the method parameter names but in a different order can cause confusion. It could indicate a mistake in the arguments' order, leading to unexpected results.
dotnet_diagnostic.S2234.severity = error
## S6800 : Component parameter type should match the route parameter type constraint (category : Major Bug / default: warning)
## In Blazor, when a route parameter constraint is applied, the value is automatically cast to the corresponding component parameter type. If the constraint type does not match the component parameter type, it can lead to confusion and potential runtime errors due to unsuccessful casting. Therefore, it is crucial to ensure that the types of route parameters and component parameters match to prevent such issues and maintain code clarity.
dotnet_diagnostic.S6800.severity = error
## S4457 : Parameter validation in "async"/"await" methods should be wrapped (category : Major Code Smell / default: warning)
## Because of the way async/await methods are rewritten by the compiler, any exceptions thrown during the parameters check will happen only when the task is observed. That could happen far away from the source of the buggy code or never happen for fire-and-forget tasks.
dotnet_diagnostic.S4457.severity = suggestion
## S4456 : Parameter validation in yielding methods should be wrapped (category : Major Code Smell / default: warning)
## Because of the way yield methods are rewritten by the compiler (they become lazily evaluated state machines) any exceptions thrown during the parameters check will happen only when the collection is iterated over. That could happen far away from the source of the buggy code.
dotnet_diagnostic.S4456.severity = suggestion
## S4428 : "PartCreationPolicyAttribute" should be used with "ExportAttribute" (category : Major Bug / default: warning)
## To customize the default behavior for an export in the Managed Extensibility Framework (MEF), applying the PartCreationPolicyAttribute is necessary. For the PartCreationPolicyAttribute to be meaningful in the context of an export, the class must also be annotated with the ExportAttribute.
dotnet_diagnostic.S4428.severity = error
## S3251 : Implementations should be provided for "partial" methods (category : Minor Code Smell / default: warning)
## partial methods allow an increased degree of flexibility in programming a system. Hooks can be added to generated code by invoking methods that define their signature, but might not have an implementation yet. But if the implementation is still missing when the code makes it to production, the compiler silently removes the call. In the best case scenario, such calls simply represent cruft, but in they worst case they are critical, missing functionality, the loss of which will lead to unexpected results at runtime.
dotnet_diagnostic.S3251.severity = error
## S5344 : Passwords should not be stored in plaintext or with a fast hashing algorithm (category : Critical Vulnerability / default: warning)
## The improper storage of passwords poses a significant security risk to software applications. This vulnerability arises when passwords are stored in plaintext or with a fast hashing algorithm. To exploit this vulnerability, an attacker typically requires access to the stored passwords.
dotnet_diagnostic.S5344.severity = error
## S5122 : Having a permissive Cross-Origin Resource Sharing policy is security-sensitive (category : Minor Security Hotspot / default: warning)
## Having a permissive Cross-Origin Resource Sharing policy is security-sensitive. It has led in the past to the following vulnerabilities:
dotnet_diagnostic.S5122.severity = error
## S4214 : "P/Invoke" methods should not be visible (category : Major Code Smell / default: warning)
## This rule is deprecated; use {rule:csharpsquid:S4200} instead.
dotnet_diagnostic.S4214.severity = error
## S4000 : Pointers to unmanaged memory should not be visible (category : Critical Code Smell / default: warning)
## Pointer and unmanaged function pointer types such as IntPtr, UIntPtr, int* etc. are used to access unmanaged memory, usually in order to use C or C++ libraries. If such a pointer is not secured by making it private, internal or readonly, it can lead to a vulnerability allowing access to arbitrary locations.
dotnet_diagnostic.S4000.severity = error
## S4581 : "new Guid()" should not be used (category : Major Code Smell / default: warning)
## When the syntax new Guid() (i.e. parameterless instantiation) is used, it must be that one of three things is wanted:
dotnet_diagnostic.S4581.severity = error
## S3967 : Multidimensional arrays should not be used (category : Minor Code Smell / default: warning)
## A jagged array is an array whose elements are arrays. It is recommended over a multidimensional array because the arrays that make up the elements can be of different sizes, which avoids wasting memory space.
dotnet_diagnostic.S3967.severity = error
## S1450 : Private fields only used as local variables in methods should become local variables (category : Minor Code Smell / default: warning)
## When the value of a private field is always assigned to in a class' methods before being read, then it is not being used to store class information. Therefore, it should become a local variable in the relevant methods to prevent any misunderstanding.
dotnet_diagnostic.S1450.severity = error
## S3398 : "private" methods called only by inner classes should be moved to those classes (category : Minor Code Smell / default: warning)
## When a private static method is only invoked by a nested class, there’s no reason not to move it into that class. It will still have the same access to the outer class' static members, but the outer class will be clearer and less cluttered.
dotnet_diagnostic.S3398.severity = error
## S4275 : Getters and setters should access the expected fields (category : Critical Bug / default: warning)
## Properties provide a way to enforce encapsulation by providing accessors that give controlled access to private fields. However, in classes with multiple fields, it is not unusual that copy-and-paste is used to quickly create the needed properties, which can result in the wrong field being accessed by a getter or setter.
dotnet_diagnostic.S4275.severity = error
## S4049 : Properties should be preferred (category : Minor Code Smell / default: warning)
## Properties are accessed like fields which makes them easier to use.
dotnet_diagnostic.S4049.severity = none
## S2372 : Exceptions should not be thrown from property getters (category : Major Code Smell / default: warning)
## Property getters should be simple operations that are always safe to call. If exceptions need to be thrown, it is best to convert the property to a method.
dotnet_diagnostic.S2372.severity = error
## S4059 : Property names should not match get methods (category : Major Code Smell / default: warning)
## Properties and Get method should have names that makes them clearly distinguishable.
dotnet_diagnostic.S4059.severity = error
## S2292 : Trivial properties should be auto-implemented (category : Minor Code Smell / default: warning)
## Trivial properties, which include no logic but setting and getting a backing field should be converted to auto-implemented properties, yielding cleaner and more readable code.
dotnet_diagnostic.S2292.severity = error
## S2376 : Write-only properties should not be used (category : Major Code Smell / default: warning)
## Properties with only setters are confusing and counterintuitive. Instead, a property getter should be added if possible, or the property should be replaced with a setter method.
dotnet_diagnostic.S2376.severity = error
## S3926 : Deserialization methods should be provided for "OptionalField" members (category : Major Bug / default: warning)
## Fields marked with System.Runtime.Serialization.OptionalFieldAttribute are serialized just like any other field. But such fields are ignored on deserialization, and retain the default values associated with their types. Therefore, deserialization event handlers should be declared to set such fields during the deserialization process.
dotnet_diagnostic.S3926.severity = error
## S2339 : Public constant members should not be used (category : Critical Code Smell / default: warning)
## Constant members are copied at compile time to the call sites, instead of being fetched at runtime.
dotnet_diagnostic.S2339.severity = none
## S5443 : Using publicly writable directories is security-sensitive (category : Critical Security Hotspot / default: warning)
## Operating systems have global directories where any user has write access. Those folders are mostly used as temporary storage areas like /tmp in Linux based systems. An application manipulating files from these folders is exposed to race conditions on filenames: a malicious user can try to create a file with a predictable name before the application does. A successful attack can result in other files being accessed, modified, corrupted or deleted. This risk is even higher if the application runs with elevated permissions.
dotnet_diagnostic.S5443.severity = error
## S2368 : Public methods should not have multidimensional array parameters (category : Blocker Code Smell / default: warning)
## Using multidimensional and jagged arrays as method parameters in C# can be challenging for developers.
dotnet_diagnostic.S2368.severity = error
## S3603 : Methods with "Pure" attribute should return a value  (category : Major Bug / default: warning)
## Marking a method with the Pure attribute indicates that the method doesn’t make any visible state changes. Therefore, a Pure method should return a result. Otherwise, it indicates a no-operation call.
dotnet_diagnostic.S3603.severity = error
## S3253 : Constructor and destructor declarations should not be redundant (category : Minor Code Smell / default: warning)
## Since the compiler will automatically invoke the base type’s no-argument constructor, there’s no need to specify its invocation explicitly. Also, when only a single public parameterless constructor is defined in a class, then that constructor can be removed because the compiler would generate it automatically. Similarly, empty static constructors and empty destructors are also wasted keystrokes.
dotnet_diagnostic.S3253.severity = error
## S3254 : Default parameter values should not be passed as arguments (category : Minor Code Smell / default: warning)
## Specifying the default parameter values in a method call is redundant. Such values should be omitted in the interests of readability.
dotnet_diagnostic.S3254.severity = none
## S1905 : Redundant casts should not be used (category : Minor Code Smell / default: warning)
## Casting expressions are utilized to convert one data type to another, such as transforming an integer into a string. This is especially crucial in strongly typed languages like C, C++, C#, Java, Python, and others.
dotnet_diagnostic.S1905.severity = error
## S3440 : Variables should not be checked against the values they're about to be assigned (category : Minor Code Smell / default: warning)
## There’s no point in checking a variable against the value you’re about to assign it. Save the cycles and lines of code, and simply perform the assignment.
dotnet_diagnostic.S3440.severity = error
## S3257 : Declarations and initializations should be as concise as possible (category : Minor Code Smell / default: warning)
## In C#, the type of a variable can often be inferred by the compiler. The use of the [var keyword](https://learn.microsoft.com/en-us/dotnet/csharp/programming-guide/classes-and-structs/implicitly-typed-local-variables) allows you to avoid repeating the type name in a variable declaration and object instantiation because the declared type can often be inferred by the compiler.
dotnet_diagnostic.S3257.severity = error
## S3257 : Declarations and initializations should be as concise as possible (category : Minor Code Smell / default: warning)
## In C#, the type of a variable can often be inferred by the compiler. The use of the [var keyword](https://learn.microsoft.com/en-us/dotnet/csharp/programming-guide/classes-and-structs/implicitly-typed-local-variables) allows you to avoid repeating the type name in a variable declaration and object instantiation because the declared type can often be inferred by the compiler.
dotnet_diagnostic.S3257.severity = error
## S1939 : Inheritance list should not be redundant (category : Minor Code Smell / default: warning)
## An inheritance list entry is redundant if:
dotnet_diagnostic.S1939.severity = error
## S3626 : Jump statements should not be redundant (category : Minor Code Smell / default: warning)
## Jump statements, such as return, yield break, goto, and continue let you change the default flow of program execution, but jump statements that direct the control flow to the original direction are just a waste of keystrokes.
dotnet_diagnostic.S3626.severity = error
## S2333 : Redundant modifiers should not be used (category : Minor Code Smell / default: warning)
## Unnecessary keywords simply clutter the code and should be removed. Specifically:
dotnet_diagnostic.S2333.severity = error
## S3610 : Nullable type comparison should not be redundant (category : Major Bug / default: warning)
## Calling GetType() on a nullable value type object returns the underlying value type. Therefore, comparing the returned Type object to typeof(Nullable<SomeType>) will either throw an NullReferenceException or the result will always be true or false and can be known at compile time.
dotnet_diagnostic.S3610.severity = error
## S4201 : Null checks should not be combined with "is" operator checks (category : Minor Code Smell / default: warning)
## There’s no need to null test in conjunction with an is test. null is not an instance of anything, so a null check is redundant.
dotnet_diagnostic.S4201.severity = error
## S4201 : Null checks should not be combined with "is" operator checks (category : Minor Code Smell / default: warning)
## There’s no need to null test in conjunction with an is test. null is not an instance of anything, so a null check is redundant.
dotnet_diagnostic.S4201.severity = error
## S1110 : Redundant pairs of parentheses should be removed (category : Major Code Smell / default: warning)
## Parentheses can disambiguate the order of operations in complex expressions and make the code easier to understand.
dotnet_diagnostic.S1110.severity = error
## S3235 : Redundant parentheses should not be used (category : Minor Code Smell / default: warning)
## Redundant parentheses are simply wasted keystrokes, and should be removed.
dotnet_diagnostic.S3235.severity = error
## S3441 : Redundant property names should be omitted in anonymous classes (category : Minor Code Smell / default: warning)
## When an anonymous type’s properties are copied from properties or variables with the same names, it yields cleaner code to omit the new type’s property name and the assignment operator.
dotnet_diagnostic.S3441.severity = error
## S3456 : "string.ToCharArray()" and "ReadOnlySpan{T}.ToArray()" should not be called redundantly (category : Minor Bug / default: warning)
## The string type offers an indexer property that allows you to treat it as a char array. Therefore, if you just need to access a specific character or iterate over all of them, the ToCharArray call should be omitted. For these cases, not omitting makes the code harder to read and less efficient as ToCharArray copies the characters from the string object into a new Unicode character array.
dotnet_diagnostic.S3456.severity = error
## S1858 : "ToString()" calls should not be redundant (category : Minor Code Smell / default: warning)
## Invoking a method designed to return a string representation of an object which is already a string is a waste of keystrokes. Similarly, explicitly invoking ToString() when the compiler would do it implicitly is also needless code-bloat.
dotnet_diagnostic.S1858.severity = error
## S1698 : "==" should not be used when "Equals" is overridden (category : Minor Code Smell / default: warning)
## Using the equality == and inequality != operators to compare two objects generally works. The operators can be overloaded, and therefore the comparison can resolve to the appropriate method. However, when the operators are used on interface instances, then == resolves to reference equality, which may result in unexpected behavior if implementing classes override Equals. Similarly, when a class overrides Equals, but instances are compared with non-overloaded ==, there is a high chance that value comparison was meant instead of the reference one.
dotnet_diagnostic.S1698.severity = error
## S2995 : "Object.ReferenceEquals" should not be used for value types (category : Major Bug / default: warning)
## In C#, the Object.ReferenceEquals method is used to compare two reference type variables. If you use this method to compare two value types, such as int, float, or bool you will not get the expected results because value type variables contain an instance of the type and not a reference to it.
dotnet_diagnostic.S2995.severity = error
## S5856 : Regular expressions should be syntactically valid (category : Critical Bug / default: warning)
## Regular expressions have their own syntax that is understood by regular expression engines. Those engines will throw an exception at runtime if they are given a regular expression that does not conform to that syntax.
dotnet_diagnostic.S5856.severity = error
## S5693 : Allowing requests with excessive content length is security-sensitive (category : Major Security Hotspot / default: warning)
## Rejecting requests with significant content length is a good practice to control the network traffic intensity and thus resource consumption in order to prevent DoS attacks.
dotnet_diagnostic.S5693.severity = error
## S3993 : Custom attributes should be marked with "System.AttributeUsageAttribute" (category : Major Code Smell / default: warning)
## When defining custom attributes, AttributeUsageAttribute must be used to indicate where the attribute can be applied. This will:
dotnet_diagnostic.S3993.severity = error
## S1168 : Empty arrays and collections should be returned instead of null (category : Major Code Smell / default: warning)
## Returning null or default instead of an actual collection forces the method callers to explicitly test for null, making the code more complex and less readable.
dotnet_diagnostic.S1168.severity = error
## S2201 : Methods without side effects should not have their return values ignored (category : Major Bug / default: warning)
## When you do not use the return value of a method with no side effects, it indicates that something is wrong. Either this method is unnecessary, or the source code does not behave as expected and could lead to code defects. For example, there are methods, such as DateTime.AddYears, that don’t change the value of the input object, but instead, they return a new object whose value is the result of this operation, and as a result that you will have unexpected effects if you do not use the return value.
dotnet_diagnostic.S2201.severity = error
## S2757 : Non-existent operators like "=+" should not be used (category : Major Bug / default: warning)
## Using operator pairs (=+, =-, or =!) that look like reversed single operators (+=, -= or !=) is confusing. They compile and run but do not produce the same result as their mirrored counterpart.
dotnet_diagnostic.S2757.severity = error
## S1109 : A close curly brace should be located at the beginning of a line (category : Minor Code Smell / default: warning)
## Shared coding conventions make it possible for a team to efficiently collaborate. This rule makes it mandatory to place a close curly brace at the beginning of a line.
dotnet_diagnostic.S1109.severity = error
## S6931 : ASP.NET controller actions should not have a route template starting with "/" (category : Major Code Smell / default: warning)
## Route templates for ASP.NET controller actions, defined via a RouteAttribute or any derivation of HttpMethodAttribute, should not start with "/".
dotnet_diagnostic.S6931.severity = error
## S3884 : "CoSetProxyBlanket" and "CoInitializeSecurity" should not be used (category : Blocker Vulnerability / default: warning)
## This rule is deprecated, and will eventually be removed.
dotnet_diagnostic.S3884.severity = error
## S1656 : Variables should not be self-assigned (category : Major Bug / default: warning)
## Re-assigning a variable to itself is a defect as it has no actual effect and indicates meaning to do something else. It usually means that:
dotnet_diagnostic.S1656.severity = error
## S4212 : Serialization constructors should be secured (category : Major Vulnerability / default: warning)
## This rule is deprecated, and will eventually be removed.
dotnet_diagnostic.S4212.severity = error
## S4057 : Locales should be set for data types (category : Major Code Smell / default: warning)
## When you create a DataTable or DataSet, you should set the locale explicitly. By default, the locale for these types is the current culture. For data that is stored in a database or file and is shared globally, the locale should ordinarily be set to the invariant culture (CultureInfo.InvariantCulture).
dotnet_diagnostic.S4057.severity = error
## S6609 : "Min/Max" properties of "Set" types should be used instead of the "Enumerable" extension methods (category : Minor Code Smell / default: warning)
## Both the Enumerable.Max extension method and the SortedSet{T}.Max property can be used to find the maximum value in a SortedSet{T}. However, SortedSet{T}.Max is much faster than Enumerable.Max. For small collections, the performance difference may be minor, but for large collections, it can be noticeable. The same applies for the Min property as well.
dotnet_diagnostic.S6609.severity = error
## S3449 : Right operands of shift operators should be integers (category : Critical Bug / default: warning)
## Numbers can be shifted with the << and >> operators, but the right operand of the operation needs to be an int or a type that has an implicit conversion to int. However, when the left operand is dynamic, the compiler’s type checking is turned off, so you can pass anything to the right of a shift operator and have it compile. And if the argument can’t be implicitly converted to int at runtime, then a RuntimeBinderException will be raised.
dotnet_diagnostic.S3449.severity = error
## S4159 : Classes should implement their "ExportAttribute" interfaces (category : Blocker Bug / default: warning)
## The Attributed Programming Model, also known as Attribute-oriented programming (@OP), is a programming model used to embed attributes within codes.
dotnet_diagnostic.S4159.severity = error
## S122 : Statements should be on separate lines (category : Major Code Smell / default: warning)
## Putting multiple statements on a single line lowers the code readability and makes debugging the code more complex.
dotnet_diagnostic.S122.severity = error
## S4056 : Overloads with a "CultureInfo" or an "IFormatProvider" parameter should be used (category : Minor Code Smell / default: warning)
## When a System.Globalization.CultureInfo or IFormatProvider object is not supplied, the default value that is supplied by the overloaded member might not have the effect that you want in all locales.
dotnet_diagnostic.S4056.severity = error
## S6934 : A Route attribute should be added to the controller when a route template is specified at the action level (category : Major Code Smell / default: warning)
## When a route template is defined through an attribute on an action method, conventional routing for that action is disabled. To maintain good practice, it’s recommended not to combine conventional and attribute-based routing within a single controller to avoid unpredicted behavior. As such, the controller should exclude itself from conventional routing by applying a [Route] attribute.
dotnet_diagnostic.S6934.severity = error
## S4058 : Overloads with a "StringComparison" parameter should be used (category : Minor Code Smell / default: warning)
## Many string operations, the Compare and Equals methods in particular, provide an overload that accepts a StringComparison enumeration value as a parameter. Calling these overloads and explicitly providing this parameter makes your code clearer and easier to maintain.
dotnet_diagnostic.S4058.severity = error
## S6444 : Not specifying a timeout for regular expressions is security-sensitive (category : Major Security Hotspot / default: warning)
## Not specifying a timeout for regular expressions can lead to a Denial-of-Service attack. Pass a timeout when using System.Text.RegularExpressions to process untrusted input because a malicious user might craft a value for which the evaluation lasts excessively long.
dotnet_diagnostic.S6444.severity = error
## S2857 : SQL keywords should be delimited by whitespace (category : Blocker Bug / default: warning)
## When concatenating strings, it is very easy to forget a whitespace.
dotnet_diagnostic.S2857.severity = error
## S2743 : Static fields should not be used in generic types (category : Major Code Smell / default: warning)
## A static field in a generic type is not shared among instances of different closed constructed types, thus LengthLimitedSingletonCollection<int>.instances and LengthLimitedSingletonCollection<string>.instances will point to different objects, even though instances is seemingly shared among all LengthLimitedSingletonCollection<> generic classes.
dotnet_diagnostic.S2743.severity = error
## S3263 : Static fields should appear in the order they must be initialized  (category : Major Bug / default: warning)
## Static field initializers are executed in the order in which they appear in the class from top to bottom. Thus, placing a static field in a class above the field or fields required for its initialization will yield unexpected results.
dotnet_diagnostic.S3263.severity = error
## S2223 : Non-constant static fields should not be visible (category : Critical Code Smell / default: warning)
## Unlike instance fields, which can only be accessed by code having a hold on the instance, static fields can be accessed by any code having visibility of the field and its type.
dotnet_diagnostic.S2223.severity = error
## S3010 : Static fields should not be updated in constructors (category : Major Code Smell / default: warning)
## Assigning a value to a static field in a constructor could cause unreliable behavior at runtime since it will change the value for all instances of the class.
dotnet_diagnostic.S3010.severity = error
## S2696 : Instance members should not write to "static" fields (category : Critical Code Smell / default: warning)
## This rule raises an issue each time a static field is updated from a non-static method or property.
dotnet_diagnostic.S2696.severity = error
## S2156 : "sealed" classes should not have "protected" members (category : Minor Code Smell / default: warning)
## The difference between private and protected visibility is that child classes can see and use protected members, but they cannot see private ones. Since a sealed class cannot have children, marking its members protected is confusingly pointless.
dotnet_diagnostic.S2156.severity = error
## S2674 : The length returned from a stream read should be checked (category : Minor Bug / default: warning)
## Invoking a stream reading method without verifying the number of bytes read can lead to erroneous assumptions. A Stream can represent any I/O operation, such as reading a file, network communication, or inter-process communication. As such, it is not guaranteed that the byte[] passed into the method will be filled with the requested number of bytes. Therefore, inspecting the value returned by the reading method is important to ensure the number of bytes read.
dotnet_diagnostic.S2674.severity = error
## S1643 : Strings should not be concatenated using '+' in a loop (category : Minor Code Smell / default: warning)
## StringBuilder is more efficient than string concatenation, especially when the operator is repeated over and over as in loops.
dotnet_diagnostic.S1643.severity = error
## S2275 : Composite format strings should not lead to unexpected behavior at runtime (category : Blocker Bug / default: warning)
## Composite format strings in C# are evaluated at runtime, which means they are not verified by the compiler. Introducing an ill-formed format item, or indexing mismatch can lead to unexpected behaviors or runtime errors. The purpose of this rule is to perform static validation on composite format strings used in various string formatting functions to ensure their correct usage. This rule validates the proper behavior of composite formats when invoking the following methods:
dotnet_diagnostic.S2275.severity = error
## S3457 : Composite format strings should be used correctly (category : Major Code Smell / default: warning)
## A [composite format string](https://learn.microsoft.com/en-us/dotnet/standard/base-types/composite-formatting) is a string that contains placeholders, represented by indices inside curly braces "{0}", "{1}", etc. These placeholders are replaced by values when the string is printed or logged.
dotnet_diagnostic.S3457.severity = error
## S1192 : String literals should not be duplicated (category : Minor Code Smell / default: warning)
## Duplicated string literals make the process of refactoring complex and error-prone, as any change would need to be propagated on all occurrences.
dotnet_diagnostic.S1192.severity = error
## S4635 : Start index should be used instead of calling Substring (category : Critical Code Smell / default: warning)
## It is important to be careful when searching for characters within a substring. Let’s consider the following example:
dotnet_diagnostic.S4635.severity = error
## S1449 : Culture should be specified for "string" operations (category : Minor Code Smell / default: warning)
## string.ToLower(), ToUpper, IndexOf, LastIndexOf, and Compare are all culture-dependent, as are some (floating point number and DateTime-related) calls to ToString. Fortunately, all have variants which accept an argument specifying the culture or formatter to use. Leave that argument off and the call will use the system default culture, possibly creating problems with international characters.
dotnet_diagnostic.S1449.severity = error
## S3876 : Strings or integral types should be used for indexers (category : Minor Code Smell / default: warning)
## Strings and integral types are typically used as indexers. When some other type is required, it typically indicates design problems, and potentially a situation where a method should be used instead.
dotnet_diagnostic.S3876.severity = error
## S3234 : "GC.SuppressFinalize" should not be invoked for types without destructors (category : Minor Code Smell / default: warning)
## GC.SuppressFinalize asks the Common Language Runtime not to call the finalizer of an object. This is useful when implementing the dispose pattern where object finalization is already handled in IDisposable.Dispose. However, it has no effect if there is no finalizer defined in the object’s type, so using it in such cases is just confusing.
dotnet_diagnostic.S3234.severity = error
## S6968 : Actions that return a value should be annotated with ProducesResponseTypeAttribute containing the return type (category : Major Code Smell / default: warning)
## In an ASP.NET Core Web API, controller actions can optionally return a result value. If a controller action returns a value in the happy path, for example ControllerBase.Ok(Object), annotating the action with one of the [ProducesResponseType] overloads that describe the type is recommended.
dotnet_diagnostic.S6968.severity = error
## S3458 : Empty "case" clauses that fall through to the "default" should be omitted (category : Minor Code Smell / default: warning)
## Empty case clauses that fall through to the default are useless. Whether or not such a case is present, the default clause will be invoked. Such cases simply clutter the code, and should be removed.
dotnet_diagnostic.S3458.severity = error
## S1301 : "switch" statements should have at least 3 "case" clauses (category : Minor Code Smell / default: warning)
## switch statements and expressions are useful when there are many different cases depending on the value of the same expression.
dotnet_diagnostic.S1301.severity = error
## S3532 : Empty "default" clauses should be removed (category : Minor Code Smell / default: warning)
## The default clause should take appropriate action. Having an empty default is a waste of keystrokes.
dotnet_diagnostic.S3532.severity = error
## S1151 : "switch case" clauses should not have too many lines of code (category : Major Code Smell / default: warning)
## The switch statement should be used only to clearly define some new branches in the control flow. As soon as a case clause contains too many statements this highly decreases the readability of the overall control flow statement. In such case, the content of the case clause should be extracted into a dedicated method.
dotnet_diagnostic.S1151.severity = error
## S1821 : "switch" statements should not be nested (category : Critical Code Smell / default: warning)
## Nested switch structures are difficult to understand because you can easily confuse the cases of an inner switch as belonging to an outer statement. Therefore nested switch statements should be avoided.
dotnet_diagnostic.S1821.severity = error
## S131 : "switch/Select" statements should contain a "default/Case Else" clauses (category : Critical Code Smell / default: warning)
## The requirement for a final default clause is defensive programming. The clause should either take appropriate action, or contain a suitable comment as to why no action is taken. Even when the switch covers all current values of an enum, a default case should still be used because there is no guarantee that the enum won’t be extended.
dotnet_diagnostic.S131.severity = error
## S3900 : Arguments of public methods should be validated against null (category : Major Code Smell / default: warning)
## Methods declared as public, protected, or protected internal can be accessed from other assemblies, which means you should validate parameters to be within the expected constraints. In general, checking against null is recommended in defensive programming.
dotnet_diagnostic.S3900.severity = error
## S3329 : Cipher Block Chaining IVs should be unpredictable (category : Critical Vulnerability / default: warning)
## This vulnerability exposes encrypted data to a number of attacks whose goal is to recover the plaintext.
dotnet_diagnostic.S3329.severity = error
## S2222 : Locks should be released on all paths (category : Critical Bug / default: warning)
## To prevent potential deadlocks in an application, it is crucial to release any locks that are acquired within a method along all possible execution paths.
dotnet_diagnostic.S2222.severity = error
## S3966 : Objects should not be disposed more than once (category : Major Code Smell / default: warning)
## Disposing an object twice in the same method, either with the using keyword or by calling Dispose directly, is confusing and error-prone. For example, another developer might try to use an already-disposed object, or there can be runtime errors for specific paths in the code.
dotnet_diagnostic.S3966.severity = error
## S2259 : Null pointers should not be dereferenced (category : Major Bug / default: warning)
## Accessing a null value will always throw a NullReferenceException most likely causing an abrupt program termination.
dotnet_diagnostic.S2259.severity = error
## S2053 : Password hashing functions should use an unpredictable salt (category : Critical Vulnerability / default: warning)
## This vulnerability increases the likelihood that attackers are able to compute the cleartext of password hashes.
dotnet_diagnostic.S2053.severity = error
## S1944 : Invalid casts should be avoided (category : Critical Code Smell / default: warning)
## A cast is an explicit conversion, which is a way to tell the compiler the intent to convert from one type to another.
dotnet_diagnostic.S1944.severity = error
## S6781 : JWT secret keys should not be disclosed (category : Blocker Vulnerability / default: warning)
## Secret leaks often occur when a sensitive piece of authentication data is stored with the source code of an application. Considering the source code is intended to be deployed across multiple assets, including source code repositories or application hosting servers, the secrets might get exposed to an unintended audience.
dotnet_diagnostic.S6781.severity = error
## S3655 : Empty nullable value should not be accessed (category : Major Bug / default: warning)
## Nullable value types can hold either a value or null.
dotnet_diagnostic.S3655.severity = error
## S4158 : Empty collections should not be accessed or iterated (category : Minor Bug / default: warning)
## When a collection is empty, iterating it has no effect. Doing so anyway is likely a bug; either population was accidentally omitted, or the iteration needs to be revised.
dotnet_diagnostic.S4158.severity = error
## S2583 : Conditionally executed code should be reachable (category : Major Bug / default: warning)
## Conditional expressions which are always true or false can lead to unreachable code.
dotnet_diagnostic.S2583.severity = error
## S2589 : Boolean expressions should not be gratuitous (category : Major Code Smell / default: warning)
## Gratuitous boolean expressions are conditions that do not change the evaluation of a program. This issue can indicate logical errors and affect the correctness of an application, as well as its maintainability.
dotnet_diagnostic.S2589.severity = error
## S4347 : Secure random number generators should not output predictable values (category : Critical Vulnerability / default: warning)
## Cryptographic operations often rely on unpredictable random numbers to enhance security. These random numbers are created by cryptographically secure pseudo-random number generators (CSPRNG). It is important not to use a predictable seed with these random number generators otherwise the random numbers will also become predictable.
dotnet_diagnostic.S4347.severity = error
## S3949 : Calculations should not overflow (category : Major Bug / default: warning)
## Numbers are infinite, but the types that hold them are not. Each numeric type has hard upper and lower bounds. Try to calculate or assign numbers beyond those bounds, and the result will be a value that has silently wrapped around from the expected positive value to a negative one, or vice versa.
dotnet_diagnostic.S3949.severity = error
## S5773 : Types allowed to be deserialized should be restricted (category : Major Vulnerability / default: warning)
## Deserialization is the process of converting serialized data (such as objects or data structures) back into their original form. Types allowed to be unserialized should be strictly controlled.
dotnet_diagnostic.S5773.severity = error
## S9999-symbolRef : Symbol reference calculator (category :  / default: warning)
dotnet_diagnostic.S9999-symbolRef.severity = error
## S105 : Tabulation characters should not be used (category : Minor Code Smell / default: warning)
## The tab width can differ from one development environment to another. Using tabs may require other developers to configure their environment (text editor, preferences, etc.) to read source code.
dotnet_diagnostic.S105.severity = error
## S3216 : "ConfigureAwait(false)" should be used (category : Critical Code Smell / default: warning)
## After an awaited Task has executed, you can continue execution in the original, calling thread or any arbitrary thread. Unless the rest of the code needs the context from which the Task was spawned, Task.ConfigureAwait(false) should be used to keep execution in the Task thread to avoid the need for context switching and the possibility of deadlocks.
dotnet_diagnostic.S3216.severity = error
## S2187 : Test classes should contain at least one test case (category : Blocker Code Smell / default: warning)
## To ensure proper testing, it is important to include test cases in a test class. If a test class does not have any test cases, it can give the wrong impression that the class being tested has been thoroughly tested, when in reality, it has not.
dotnet_diagnostic.S2187.severity = error
## S2699 : Tests should include assertions (category : Blocker Code Smell / default: warning)
## The rule targets test methods that lack an assertion and consist solely of an action and, optionally, a setup.
dotnet_diagnostic.S2699.severity = error
## S3433 : Test method signatures should be correct (category : Blocker Code Smell / default: warning)
## A method is identified as a test method if it is marked with one of the following attributes:
dotnet_diagnostic.S3433.severity = error
## S1607 : Tests should not be ignored (category : Major Code Smell / default: warning)
## When a test fails due, for example, to infrastructure issues, you might want to ignore it temporarily. But without some kind of notation about why the test is being ignored, it may never be reactivated. Such tests are difficult to address without comprehensive knowledge of the project, and end up polluting their projects.
dotnet_diagnostic.S1607.severity = error
## S2925 : "Thread.Sleep" should not be used in tests (category : Major Code Smell / default: warning)
## Using Thread.Sleep in a test might introduce unpredictable and inconsistent results depending on the environment. Furthermore, it will block the thread, which means the system resources are not being fully used.
dotnet_diagnostic.S2925.severity = error
## S3366 : "this" should not be exposed from constructors (category : Major Code Smell / default: warning)
## In single-threaded environments, the use of this in constructors is normal, and expected. But in multi-threaded environments, it could expose partially-constructed objects to other threads, and should be used with caution.
dotnet_diagnostic.S3366.severity = error
## S3889 : "Thread.Resume" and "Thread.Suspend" should not be used (category : Blocker Bug / default: warning)
## Thread.Suspend and Thread.Resume can give unpredictable results, and both methods have been deprecated. Indeed, if Thread.Suspend is not used very carefully, a thread can be suspended while holding a lock, thus leading to a deadlock.
dotnet_diagnostic.S3889.severity = error
## S3005 : "ThreadStatic" should not be used on non-static fields (category : Major Bug / default: warning)
## When you annotate a field with the ThreadStatic attribute, it is an indication that the value of this field is unique for each thread. But if you don’t mark the field as static, then the ThreadStatic attribute is ignored.
dotnet_diagnostic.S3005.severity = error
## S2996 : "ThreadStatic" fields should not be initialized (category : Major Bug / default: warning)
## When an object has a field annotated with ThreadStatic, that field is shared within a given thread, but unique across threads. Since a class' static initializer is only invoked for the first thread created, it also means that only the first thread will have the expected initial values.
dotnet_diagnostic.S2996.severity = error
## S112 : General or reserved exceptions should never be thrown (category : Major Code Smell / default: warning)
## This rule raises an issue when a general or reserved exception is thrown.
dotnet_diagnostic.S112.severity = error
## S9999-token-type : Token type calculator (category :  / default: warning)
dotnet_diagnostic.S9999-token-type.severity = error
## S2436 : Types and methods should not have too many generic parameters (category : Major Code Smell / default: warning)
## A method or class with too many type parameters has likely aggregated too many responsibilities and should be split.
dotnet_diagnostic.S2436.severity = error
## S1479 : "switch" statements with many "case" clauses should have only one statement (category : Major Code Smell / default: warning)
## When switch statements have large sets of multi-line case clauses, the code becomes hard to read and maintain.
dotnet_diagnostic.S1479.severity = error
## S6664 : The code block contains too many logging calls (category : Minor Code Smell / default: warning)
## A code block should not contain too many logging statements of a specific level.
dotnet_diagnostic.S6664.severity = error
## S107 : Methods should not have too many parameters (category : Major Code Smell / default: warning)
## Methods with a long parameter list are difficult to use because maintainers must figure out the role of each parameter and keep track of their position.
dotnet_diagnostic.S107.severity = error
## S2225 : "ToString()" method should not return null (category : Major Bug / default: warning)
## Calling ToString() on an object should always return a string. Thus, overriding the ToString method should never return null, as it breaks the method’s implicit contract, and as a result the consumer’s expectations.
dotnet_diagnostic.S2225.severity = error
## S3717 : Track use of "NotImplementedException" (category : Minor Code Smell / default: warning)
## NotImplementedException is often used to mark methods which must be implemented for the overall functionality to be complete, but which the developer wants to implement later. That’s as opposed to the NotSupportedException which is thrown by methods which are required by base classes or interfaces, but which are not appropriate to the current class.
dotnet_diagnostic.S3717.severity = error
## S2327 : "try" statements with identical "catch" and/or "finally" blocks should be merged (category : Major Code Smell / default: warning)
## When multiple, adjacent try statements have duplicate catch and/or finally blocks, they should be merged to consolidate the catch/finally logic for cleaner, more readable code. Note that this applies even when there is intervening code outside any try block.
dotnet_diagnostic.S2327.severity = error
## S3443 : Type should not be examined on "System.Type" instances (category : Blocker Code Smell / default: warning)
## Calling GetType on a Type variable will always return the System.Type representation, which is equivalent to typeof(System.Type). This also applies to passing a Type argument to IsInstanceOfType which always returns false.
dotnet_diagnostic.S3443.severity = error
## S4041 : Type names should not match namespaces (category : Minor Code Smell / default: warning)
## When a type name matches the name of a publicly defined namespace, for instance one in the .NET framework class library, it leads to confusion and makes the library that much harder to use.
dotnet_diagnostic.S4041.severity = error
## S4052 : Types should not extend outdated base types (category : Minor Code Smell / default: warning)
## With the advent of .NET Framework 2.0, certain practices and types have become obsolete.
dotnet_diagnostic.S4052.severity = error
## S2761 : Doubled prefix operators "!!" and "~~" should not be used (category : Major Bug / default: warning)
## The repetition of a prefix operator (!, or ~) is usually a typo. The second operator invalidates the first one.
dotnet_diagnostic.S2761.severity = error
## S3353 : Unchanged variables should be marked as "const" (category : Critical Code Smell / default: warning)
## If a variable that is not supposed to change is not marked as const, it could be accidentally reassigned elsewhere in the code, leading to unexpected behavior and bugs that can be hard to track down.
dotnet_diagnostic.S3353.severity = error
## S1751 : Loops with at most one iteration should be refactored (category : Major Bug / default: warning)
## A loop statement with at most one iteration is equivalent to an if statement; the following block is executed only once.
dotnet_diagnostic.S1751.severity = error
## S3264 : Events should be invoked (category : Major Code Smell / default: warning)
## Events that are not invoked anywhere are dead code, and there’s no good reason to keep them in the source.
dotnet_diagnostic.S3264.severity = error
## S2437 : Unnecessary bit operations should not be performed (category : Blocker Code Smell / default: suggestion)
## Certain bitwise operations are not needed and should not be performed because their results are predictable.
dotnet_diagnostic.S2437.severity = error
## S2198 : Unnecessary mathematical comparisons should not be made (category : Critical Code Smell / default: warning)
## Certain mathematical comparisons will always return the same value, and should not be performed.
dotnet_diagnostic.S2198.severity = error
## S1128 : Unnecessary "using" should be removed (category : Minor Code Smell / default: warning)
## Unnecessary using directives refer to importing namespaces, types or creating aliases that are not used or referenced anywhere in the code.
dotnet_diagnostic.S1128.severity = error
## S6640 : Using unsafe code blocks is security-sensitive (category : Major Security Hotspot / default: warning)
## Using unsafe code blocks can lead to unintended security or stability risks.
dotnet_diagnostic.S6640.severity = error
## S4487 : Unread "private" fields should be removed (category : Critical Code Smell / default: warning)
## Private fields which are written but never read are a case of "dead store". Changing the value of such a field is useless and most probably indicates an error in the code.
dotnet_diagnostic.S4487.severity = error
## S3241 : Methods should not return values that are never used (category : Minor Code Smell / default: warning)
## Private methods are intended for use only within their scope. If these methods return values that are not utilized by any calling functions, it indicates that the return operation is unnecessary. Removing such returns can enhance both efficiency and code clarity.
dotnet_diagnostic.S3241.severity = error
## S3063 : "StringBuilder" data should be used (category : Major Code Smell / default: warning)
## StringBuilder instances that never build a string clutter the code and worse are a drag on performance. Either they should be removed, or the missing ToString() call should be added.
dotnet_diagnostic.S3063.severity = error
## S1075 : URIs should not be hardcoded (category : Minor Code Smell / default: warning)
## Hard-coding a URI makes it difficult to test a program for a variety of reasons:
dotnet_diagnostic.S1075.severity = error
## S6932 : Use model binding instead of reading raw request data (category : Major Code Smell / default: warning)
## The HttpRequest class provides access to the raw request data through the QueryString, Headers, and Forms properties. However, whenever possible it is recommended to use model binding instead of directly accessing the input data.
dotnet_diagnostic.S6932.severity = error
## S6966 : Awaitable method should be used (category : Major Code Smell / default: warning)
## In an async method, any blocking operations should be avoided.
dotnet_diagnostic.S6966.severity = error
## S6610 : "StartsWith" and "EndsWith" overloads that take a "char" should be used instead of the ones that take a "string" (category : Minor Code Smell / default: warning)
## With string.StartsWith(char) and string.EndsWith(char), only the first character of the string is compared to the provided character, whereas the string versions of those methods have to do checks about the current StringComparison and CultureInfo. Thus, the char overloads are significantly faster for default comparison scenarios.
dotnet_diagnostic.S6610.severity = error
## S2629 : Logging templates should be constant (category : Major Code Smell / default: warning)
## Logging arguments should not require evaluation in order to avoid unnecessary performance overhead. When passing concatenated strings or string interpolations directly into a logging method, the evaluation of these expressions occurs every time the logging method is called, regardless of the log level. This can lead to inefficient code execution and increased resource consumption.
dotnet_diagnostic.S2629.severity = error
## S3962 : "static readonly" constants should be "const" instead (category : Minor Code Smell / default: warning)
## The value of a static readonly field is computed at runtime while the value of a const field is calculated at compile time, which improves performance.
dotnet_diagnostic.S3962.severity = error
## S121 : Control structures should use curly braces (category : Critical Code Smell / default: warning)
## Control structures are code statements that impact the program’s control flow (e.g., if statements, for loops, etc.)
dotnet_diagnostic.S121.severity = error
## S6566 : Use "DateTimeOffset" instead of "DateTime" (category : Major Code Smell / default: warning)
## This rule recommends using DateTimeOffset instead of DateTime for projects targeting .NET Framework 2.0 or later.
dotnet_diagnostic.S6566.severity = suggestion
## S6575 : Use "TimeZoneInfo.FindSystemTimeZoneById" without converting the timezones with "TimezoneConverter" (category : Major Code Smell / default: warning)
## Since .NET 6 you don’t have to use the TimeZoneConverter library to manually do the conversion between IANA and Windows timezones. The .NET 6.0 introduced new Time Zone enhancements, one being the TimeZoneInfo.FindSystemTimeZoneById(string timezone) method now accepts as input both IANA and Windows time zone IDs on any operating system with installed time zone data. TimeZoneInfo.FindSystemTimeZoneById will automatically convert its input from IANA to Windows and vice versa if the requested time zone is not found on the system.
dotnet_diagnostic.S6575.severity = error
## S3908 : Generic event handlers should be used (category : Major Code Smell / default: warning)
## Since .Net Framework version 2.0 it is not necessary to declare a delegate that specifies a class derived from System.EventArgs. The System.EventHandler<TEventArgs> delegate mechanism should be used instead as it allows any class derived from EventArgs to be used with that handler.
dotnet_diagnostic.S3908.severity = error
## S4047 : Generics should be used when appropriate (category : Minor Code Smell / default: warning)
## When a reference parameter (keyword ref) is used, the passed argument type must exactly match the reference parameter type. This means that to be able to pass a derived type, it must be cast and assigned to a variable of the proper type. Use of generic methods eliminates that cumbersome down casting and should therefore be preferred.
dotnet_diagnostic.S4047.severity = error
## S6580 : Use a format provider when parsing date and time (category : Major Code Smell / default: warning)
## When converting a string representation of a date and time to a DateTime object or any other temporal type with one of the available system parsing methods, you should always provide an IFormatProvider parameter.
dotnet_diagnostic.S6580.severity = error
## S6608 : Prefer indexing instead of "Enumerable" methods on types implementing "IList" (category : Minor Code Smell / default: warning)
## Indexes in C# provide direct access to an element at a specific position within an array or collection. When compared to Enumerable methods, indexing can be more efficient for certain scenarios, such as iterating over a large collection, due to avoiding the overhead of checking the underlying collection type before accessing it.
dotnet_diagnostic.S6608.severity = error
## S6612 : The lambda parameter should be used instead of capturing arguments in "ConcurrentDictionary" methods (category : Minor Code Smell / default: warning)
## When using the ConcurrentDictionary, there are many overloads of the GetOrAdd and AddOrUpdate methods that take both a TKey argument and a lambda that expects a TKey parameter. This means that the right side of the lambda can be written using either the lambda’s parameter or the method’s argument. However, using the method’s argument leads to the lambda capturing it, and the compiler will need to generate a class and instantiate it before the call. This means memory allocations, as well as more time spend during Garbage Collection.
dotnet_diagnostic.S6612.severity = error
## S2148 : Underscores should be used to make large numbers readable (category : Minor Code Smell / default: warning)
## Beginning with C# 7, it is possible to add underscores ('_') to numeric literals to enhance readability. The addition of underscores in this manner has no semantic meaning, but makes it easier for maintainers to understand the code.
dotnet_diagnostic.S2148.severity = error
## S4061 : "params" should be used instead of "varargs" (category : Minor Code Smell / default: warning)
## A method using the VarArgs calling convention is not Common Language Specification (CLS) compliant and might not be accessible across programming languages, while the params keyword works the same way and is CLS compliant.
dotnet_diagnostic.S4061.severity = error
## S2178 : Short-circuit logic should be used in boolean contexts (category : Blocker Code Smell / default: warning)
## Short-circuit evaluation is an evaluation strategy for Boolean operators, that doesn’t evaluates the second argument of the operator if it is not needed to determine the result of the operation.
dotnet_diagnostic.S2178.severity = error
## S6618 : "string.Create" should be used instead of "FormattableString" (category : Minor Code Smell / default: warning)
## In order to produce a formatted string, both string.Create and either FormattableString.Invariant or FormattableString.CurrentCulture can be used. However, string.Create rents array buffers from ArrayPool<char> making it more performant, as well as preventing unnecessary allocations and future stress on the Garbage Collector.
dotnet_diagnostic.S6618.severity = error
## S3256 : "string.IsNullOrEmpty" should be used (category : Minor Code Smell / default: warning)
## Using string.Equals to determine if a string is empty is significantly slower than using string.IsNullOrEmpty() or checking for string.Length == 0. string.IsNullOrEmpty() is both clear and concise, and therefore preferred to laborious, error-prone, manual null- and emptiness-checking.
dotnet_diagnostic.S3256.severity = error
## S6354 : Use a testable date/time provider (category : Major Code Smell / default: warning)
## One of the principles of a unit test is that it must have full control of the system under test. This is problematic when production code includes calls to static methods, which cannot be changed or controlled. Date/time functions are usually provided by system libraries as static methods.
dotnet_diagnostic.S6354.severity = error
## S6603 : The collection-specific "TrueForAll" method should be used instead of the "All" extension (category : Minor Code Smell / default: warning)
## Both the List.TrueForAll method and the IEnumerable.All method can be used to check if all list elements satisfy a given condition in a collection. However, List.TrueForAll can be faster than IEnumerable.All for List objects. The performance difference may be minor for small collections, but for large collections, it can be noticeable.
dotnet_diagnostic.S6603.severity = error
## S6588 : Use the "UnixEpoch" field instead of creating "DateTime" instances that point to the beginning of the Unix epoch (category : Minor Code Smell / default: warning)
## With .NET Core the UnixEpoch field was introduced to DateTime and DateTimeOffset types. Using this field clearly states that the intention is to use the beginning of the Unix epoch.
dotnet_diagnostic.S6588.severity = error
## S3994 : URI Parameters should not be strings (category : Major Code Smell / default: warning)
## String representations of URIs or URLs are prone to parsing and encoding errors which can lead to vulnerabilities. The System.Uri class is a safe alternative and should be preferred. At minimum, an overload of the method taking a System.Uri as a parameter should be provided in each class that contains a method with an apparent Uri passed as a string.
dotnet_diagnostic.S3994.severity = error
## S3995 : URI return values should not be strings (category : Major Code Smell / default: warning)
## String representations of URIs or URLs are prone to parsing and encoding errors which can lead to vulnerabilities. The System.Uri class is a safe alternative and should be preferred.
dotnet_diagnostic.S3995.severity = error
## S3996 : URI properties should not be strings (category : Major Code Smell / default: warning)
## String representations of URIs or URLs are prone to parsing and encoding errors which can lead to vulnerabilities. The System.Uri class is a safe alternative and should be preferred.
dotnet_diagnostic.S3996.severity = error
## S3997 : String URI overloads should call "System.Uri" overloads (category : Major Code Smell / default: warning)
## String representations of URIs or URLs are prone to parsing and encoding errors which can lead to vulnerabilities. The System.Uri class is a safe alternative and should be preferred.
dotnet_diagnostic.S3997.severity = error
## S3237 : "value" contextual keyword should be used (category : Blocker Code Smell / default: warning)
## When you need to get external input for set and init methods defined for properties and indexers or for remove and add methods for events, you should always get this input throught the value contextual keyword.
dotnet_diagnostic.S3237.severity = error
## S6607 : The collection should be filtered before sorting by using "Where" before "OrderBy" (category : Minor Code Smell / default: warning)
## When working with LINQ in C#, it is recommended to pay attention to the order in which methods are chained, especially when using Where and OrderBy methods. It is advised to call the Where method before OrderBy because Where filters the elements of the sequence based on a given condition and returns a new sequence containing only the elements that satisfy that condition. Calling OrderBy before Where, may end up sorting elements that will be later discarded, which can lead to inefficiency. Conversely, calling Where before OrderBy, will first filter the sequence to include only the elements of interest, and then sort them based on the specified order.
dotnet_diagnostic.S6607.severity = error
## S1264 : A "while" loop should be used instead of a "for" loop (category : Minor Code Smell / default: warning)
## When only the condition expression is defined in a for loop, and the initialization and increment expressions are missing, a while loop should be used instead to increase readability.
dotnet_diagnostic.S1264.severity = error
## S2257 : Using non-standard cryptographic algorithms is security-sensitive (category : Critical Security Hotspot / default: warning)
## The use of a non-standard algorithm is dangerous because a determined attacker may be able to break the algorithm and compromise whatever data has been protected. Standard algorithms like AES, RSA, SHA, …​ should be used instead.
dotnet_diagnostic.S2257.severity = error
## S2123 : Values should not be uselessly incremented (category : Major Bug / default: warning)
## When using the postfix increment operator, it is important to know that the result of the expression x++ is the value before the operation x.
dotnet_diagnostic.S2123.severity = error
## S3898 : Value types should implement "IEquatable{T}" (category : Major Code Smell / default: warning)
## If you’re using a struct, it is likely because you’re interested in performance. But by failing to implement IEquatable{T} you’re loosing performance when comparisons are made because without IEquatable{T}, boxing and reflection are used to make comparisons.
dotnet_diagnostic.S3898.severity = error
## S1117 : Local variables should not shadow class fields or properties (category : Major Code Smell / default: warning)
## Shadowing occurs when a local variable has the same name as a variable, field, or property in an outer scope.
dotnet_diagnostic.S1117.severity = error
## S1481 : Unused local variables should be removed (category : Minor Code Smell / default: warning)
## An unused local variable is a variable that has been declared but is not used anywhere in the block of code where it is defined. It is dead code, contributing to unnecessary complexity and leading to confusion when reading the code. Therefore, it should be removed from your code to maintain clarity and efficiency.
dotnet_diagnostic.S1481.severity = error
## S2290 : Field-like events should not be virtual (category : Critical Code Smell / default: warning)
## Field-like events are events that do not have explicit add and remove accessors.
dotnet_diagnostic.S2290.severity = error
## S3597 : "ServiceContract" and "OperationContract" attributes should be used together (category : Major Code Smell / default: warning)
## The ServiceContract attribute specifies that a class or interface defines the communication contract of a Windows Communication Foundation (WCF) service. The service operations of this class or interface are defined by OperationContract attributes added to methods. It doesn’t make sense to define a contract without any service operations; thus, in a ServiceContract class or interface at least one method should be annotated with OperationContract. Similarly, WCF only serves OperationContract methods that are defined inside ServiceContract classes or interfaces; thus, this rule also checks that ServiceContract is added to the containing type of OperationContract methods.
dotnet_diagnostic.S3597.severity = error
## S3598 : One-way "OperationContract" methods should have "void" return type (category : Major Bug / default: warning)
## When declaring a Windows Communication Foundation (WCF) OperationContract method as one-way, that service method won’t return any result, not even an underlying empty confirmation message. These are fire-and-forget methods that are useful in event-like communication. Therefore, specifying a return type has no effect and can confuse readers.
dotnet_diagnostic.S3598.severity = error
## S4423 : Weak SSL/TLS protocols should not be used (category : Critical Vulnerability / default: warning)
## This vulnerability exposes encrypted data to a number of attacks whose goal is to recover the plaintext.
dotnet_diagnostic.S4423.severity = error
## S2755 : XML parsers should not be vulnerable to XXE attacks (category : Blocker Vulnerability / default: warning)
## This vulnerability allows the usage of external entities in XML.
dotnet_diagnostic.S2755.severity = error
## S6377 : XML signatures should be validated securely (category : Major Vulnerability / default: warning)
## XML signatures are a method used to ensure the integrity and authenticity of XML documents. However, if XML signatures are not validated securely, it can lead to potential vulnerabilities.
dotnet_diagnostic.S6377.severity = error
## IDE1006 : Naming styles should be followed (category : Style / default: warning)
dotnet_diagnostic.IDE1006.severity = error
